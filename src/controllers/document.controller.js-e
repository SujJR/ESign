const Document = require('../models/document.model');
const Log = require('../models/log.model');
const { ApiError, formatResponse } = require('../utils/apiUtils');
const logger = require('../utils/logger');
const documentUtils = require('../utils/documentUtils');
const documentProcessor = require('../utils/documentProcessor');

// Import enhanced Adobe Sign client instead of regular client
const { 
  createAdobeSignClient: originalCreateAdobeSignClient, 
  getAccessToken, 
  uploadTransientDocument, 
  getAgreementInfo, 
  getComprehensiveAgreementInfo,
  sendReminder, 
  createWebhook, 
  getSigningUrl, 
  downloadSignedDocument 
} = require('../config/adobeSign');

// Import enhanced Adobe Sign client
const createEnhancedAdobeSignClient = require('../config/enhancedAdobeSignClient');

// Create wrapper function to always use the enhanced client
const createAdobeSignClient = async () => {
  try {
    return await createEnhancedAdobeSignClient();
  } catch (error) {
    logger.warn(`Error creating enhanced client, falling back to original: ${error.message}`);
    return await originalCreateAdobeSignClient();
  }
};
const fs = require('fs');
const path = require('path');
const mime = require('mime');
const { createAgreementWithBestApproach, verifyAdobeSignTextTags } = require('../utils/adobeSignFormFields');
const adobeSignTemplateHandler = require('../utils/adobeSignTemplateHandler');
const adobeSignTagHandler = require('../utils/adobeSignTagHandler');
const adobeSignBypass = require('../utils/adobeSignBypass');
const emailService = require('../services/emailService');
const urlUtils = require('../utils/urlUtils');
const { recoverDocument: recoverDocumentUtil } = require('../utils/documentRecovery');

/**
 * Helper function to extract recipients from template data
 * @param {Object} templateData - Template data containing recipient information
 * @returns {Array} - Array of recipient objects
 */
const extractRecipientsFromTemplateData = (templateData) => {
  const recipients = [];
  const emailSet = new Set(); // Track emails to prevent duplicates
  
  // PRIORITY 1: Check for explicit recipients array first
  if (templateData.recipients && Array.isArray(templateData.recipients) && templateData.recipients.length > 0) {
    logger.info('Using explicit recipients array from template data');
    templateData.recipients.forEach((recipient, index) => {
      if (recipient.name && recipient.email && !emailSet.has(recipient.email.toLowerCase())) {
        emailSet.add(recipient.email.toLowerCase());
        recipients.push({
          name: recipient.name,
          email: recipient.email,
          title: recipient.title || '',
          signatureField: recipient.signatureField || `signature_recipient_${index + 1}`
        });
      }
    });
  } else {
    // PRIORITY 2: Fall back to individual field patterns only if no recipients array
    logger.info('No recipients array found, extracting from individual fields');
    const recipientFields = [
      { nameField: 'signerName', emailField: 'signerEmail', titleField: 'signerTitle' },
      { nameField: 'clientName', emailField: 'clientEmail', titleField: 'clientTitle' },
      { nameField: 'witnessName', emailField: 'witnessEmail', titleField: 'witnessTitle' }
      // Note: Removed projectManager and approverName as they are typically not signers
    ];
    
    // Extract recipients based on field patterns
    recipientFields.forEach((fieldSet, index) => {
      const name = templateData[fieldSet.nameField];
      const email = templateData[fieldSet.emailField];
      const title = templateData[fieldSet.titleField];
      
      if (name && email && !emailSet.has(email.toLowerCase())) {
        emailSet.add(email.toLowerCase());
        recipients.push({
          name: name,
          email: email,
          title: title || '',
          signatureField: `signature_${fieldSet.nameField.toLowerCase().replace('name', '')}`
        });
      }
    });
  }
  
  logger.info(`Extracted ${recipients.length} unique recipients for signature from template data`);
  return recipients;
};

/**
 * Upload a document for e-signature with optional JSON data for template processing
 * @route POST /api/documents/upload
 */
exports.uploadDocument = async (req, res, next) => {
  try {
    if (!req.file) {
      return next(new ApiError(400, 'No document uploaded'));
    }
    
    // Extract file information
    const { filename, originalname, mimetype, size, path: filePath } = req.file;
    
    // Initialize document data
    let documentData = {
      filename,
      originalName: originalname,
      fileSize: size,
      filePath,
      mimeType: mimetype,
      status: 'uploaded'
    };
    
    // Check if it's a PDF or needs processing
    const fileExtension = path.extname(originalname).toLowerCase();
    let finalPdfPath = filePath;
    let pageCount = 0;
    
    if (fileExtension === '.pdf') {
      // Analyze PDF to get page count
      const pdfInfo = await documentUtils.analyzePdf(filePath);
      pageCount = pdfInfo.pageCount;
    } else if (['.docx', '.doc'].includes(fileExtension)) {
      // Process DOCX/DOC file
      try {
        // Analysis and processing logic for DOCX/DOC
        const analysis = await documentProcessor.analyzeDocumentForSignatureFields(filePath);
        
        documentData.templateVariables = analysis.templateVariables;
        documentData.documentAnalysis = analysis;
        
        // Check for Adobe Sign tags before attempting standard processing
        const hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(filePath);
        
        if (hasAdobeSignTags) {
          logger.info('Detected Adobe Sign tags in document, using direct bypass processing');
          documentData.containsAdobeSignTags = true;
          
          if (Object.keys(templateData).length > 0) {
            // Use the direct bypass approach for maximum tag preservation
            try {
              logger.info('Using direct bypass approach for Adobe Sign tags');
              processedFilePath = await adobeSignBypass.bypassTemplateProcessing(filePath, templateData);
              documentData.processedFilePath = processedFilePath;
              finalPdfPath = await adobeSignBypass.convertToPdf(processedFilePath);
            } catch (bypassError) {
              logger.warn(`Direct bypass failed: ${bypassError.message}, trying specialized handler...`);
              // Fall back to the specialized handler
              processedFilePath = await documentProcessor.processDocumentWithAdobeSignTags(filePath, templateData);
              documentData.processedFilePath = processedFilePath;
              finalPdfPath = await documentProcessor.convertDocxToPdf(processedFilePath);
            }
          } else {
            // No template data, just convert to PDF
            finalPdfPath = await documentProcessor.convertDocxToPdf(filePath);
          }
        } else {
          // Standard template processing path (no Adobe Sign tags)
          if (Object.keys(templateData).length > 0) {
            processedFilePath = await documentProcessor.processDocumentTemplate(filePath, templateData);
            documentData.processedFilePath = processedFilePath;
            finalPdfPath = await documentProcessor.convertDocxToPdf(processedFilePath);
          } else {
            finalPdfPath = await documentProcessor.convertDocxToPdf(filePath);
          }
        }
        
        documentData.pdfFilePath = finalPdfPath;
        documentData.autoDetectedSignatureFields = (analysis.signatureFields || []).map(field => {
          if (typeof field === 'object' && field.name) {
            // Field is an object with positioning data - extract the proper structure for Adobe Sign
            return {
              name: field.name,
              type: field.type.toLowerCase(),
              required: true,
              x: field.x,
              y: field.y,
              width: field.width,
              height: field.height,
              page: field.page,
              detected: true
            };
          } else {
            // Fallback for string-based fields
            return {
              name: field,
              type: 'signature',
              required: true
            };
          }
        });
        
        // Analyze the converted PDF
        const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
        pageCount = pdfInfo.pageCount;
        
        // Check if the document has Adobe Sign text tags and verify their format
        if (documentData.autoDetectedSignatureFields && documentData.autoDetectedSignatureFields.length > 0) {
          const verificationResult = verifyAdobeSignTextTags(documentData.autoDetectedSignatureFields);
          if (verificationResult.hasTags) {
            logger.info('Adobe Sign text tags detected in document');
            
            if (!verificationResult.correctFormat) {
              logger.warn('Issues found with Adobe Sign text tags:');
              verificationResult.issuesFound.forEach(issue => logger.warn(`- ${issue}`));
              logger.warn('Recommendations:');
              verificationResult.recommendations.forEach(rec => logger.warn(`- ${rec}`));
              
              // If there are issues, add a message to the response
              documentData.textTagIssues = verificationResult.issuesFound;
              documentData.textTagRecommendations = verificationResult.recommendations;
            } else {
              logger.info('Adobe Sign text tags verification passed - signatures should appear at tag positions');
            }
            
            documentData.hasAdobeSignTags = true;
          }
        }
        
        logger.info(`Document processed successfully. Found ${analysis.templateVariables.length} template variables`);
      } catch (processingError) {
        logger.error(`Error processing document: ${processingError.message}`);
        
        // Check if this might be an Adobe Sign tag related error
        // The specific error you're seeing is "Template Error: Multi error"
        if (processingError.message.includes('Multi error') || 
            processingError.message.includes('Template Error') ||
            processingError.message.includes('unopened tag') ||
            processingError.message.includes('unclosed tag') ||
            processingError.message.includes('Error: {')) {
          
          try {
            logger.info('Detected potential Adobe Sign tag related error, checking document');
            // Check for Adobe Sign tags in the document
            const hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(filePath);
            
            if (hasAdobeSignTags) {
              logger.info('Adobe Sign tags detected, using specialized processing instead');
              
              // Use the specialized handler for Adobe Sign tags
              processedFilePath = await documentProcessor.processDocumentWithAdobeSignTags(filePath, templateData);
              documentData.processedFilePath = processedFilePath;
              documentData.hasAdobeSignTags = true;
              
              // Convert processed document to PDF
              finalPdfPath = await documentProcessor.convertDocxToPdf(processedFilePath);
              documentData.pdfFilePath = finalPdfPath;
              
              // Analyze the converted PDF
              const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
              pageCount = pdfInfo.pageCount;
              
              logger.info('Successfully recovered from template error using Adobe Sign handler');
            } else {
              // If not Adobe Sign tags, re-throw original error
              throw processingError;
            }
          } catch (recoveryError) {
            if (recoveryError !== processingError) {
              logger.error(`Recovery attempt failed: ${recoveryError.message}`);
            }
            return next(new ApiError(400, `Error processing document template: ${processingError.message}`));
          }
        } else {
          return next(new ApiError(400, `Error processing document: ${processingError.message}`));
        }
      }
    } else {
      return next(new ApiError(400, 'Unsupported file format. Only PDF, DOCX, and DOC files are allowed'));
    }
    
    documentData.pageCount = pageCount;
    
    // Create document record in database
    const document = await Document.create(documentData);
    
    // Log document upload
    await Log.create({
      level: 'info',
      message: `Document uploaded: ${originalname}`,
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,
      requestMethod: req.method,
      metadata: {
        fileSize: size,
        mimeType: mimetype,
        templateVariables: documentData.templateVariables || [],
        autoDetectedFields: documentData.autoDetectedSignatureFields?.length || 0
      }
    });
    
    logger.info(`Document uploaded: ${originalname}`);
    
    res.status(201).json(formatResponse(
      201,
      'Document uploaded successfully',
      { 
        document,
        templateVariables: documentData.templateVariables || [],
        autoDetectedSignatureFields: documentData.autoDetectedSignatureFields || []
      }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Upload a document with JSON data for template processing
 * @route POST /api/documents/upload-with-data
 */
exports.uploadDocumentWithData = async (req, res, next) => {
  try {
    if (!req.files || (!req.files.document && !req.files.documents)) {
      return next(new ApiError(400, 'No document uploaded'));
    }
    
    // Support both 'document' and 'documents' field names
    const documentFile = req.files.document ? req.files.document[0] : req.files.documents[0];
    const dataFile = req.files.data ? req.files.data[0] : null;
    
    // Extract file information
    const { filename, originalname, mimetype, size, path: filePath } = documentFile;
    
    // Parse JSON data if provided
    let templateData = {};
    if (dataFile) {
      try {
        const jsonContent = fs.readFileSync(dataFile.path, 'utf8');
        templateData = JSON.parse(jsonContent);
        
        // Clean up the temporary JSON file
        fs.unlinkSync(dataFile.path);
        
        logger.info(`JSON data file processed with ${Object.keys(templateData).length} variables`);
      } catch (jsonError) {
        logger.error(`Error parsing JSON data: ${jsonError.message}`);
        return next(new ApiError(400, 'Invalid JSON data file'));
      }
    }
    
    // Parse JSON data from request body if provided instead of file
    if (!dataFile && req.body.templateData) {
      try {
        templateData = typeof req.body.templateData === 'string' 
          ? JSON.parse(req.body.templateData) 
          : req.body.templateData;
      } catch (jsonError) {
        logger.error(`Error parsing JSON data from body: ${jsonError.message}`);
        return next(new ApiError(400, 'Invalid JSON data in request body'));
      }
    }
    
    // Initialize document data
    let documentData = {
      filename,
      originalName: originalname,
      fileSize: size,
      filePath,
      mimeType: mimetype,
      status: 'uploaded',
      templateData
    };
    
    // Check if it's a PDF or needs processing
    const fileExtension = path.extname(originalname).toLowerCase();
    let finalPdfPath = filePath;
    let pageCount = 0;
    let processedFilePath = null;
    
    if (fileExtension === '.pdf') {
      // Analyze PDF to get page count
      const pdfInfo = await documentUtils.analyzePdf(filePath);
      pageCount = pdfInfo.pageCount;
      
      // Even PDFs can have template variables in text layers
      try {
        const analysis = await documentProcessor.analyzeDocumentForSignatureFields(filePath);
        documentData.templateVariables = analysis.templateVariables;
        documentData.documentAnalysis = analysis;
        documentData.autoDetectedSignatureFields = (analysis.signatureFields || []).map(field => {
          if (typeof field === 'object' && field.name) {
            return {
              name: field.name,
              type: field.type.toLowerCase(),
              required: true,
              x: field.x,
              y: field.y,
              width: field.width,
              height: field.height,
              page: field.page,
              detected: true
            };
          } else {
            return {
              name: field,
              type: 'signature',
              required: true
            };
          }
        });
      } catch (analysisError) {
        logger.warn(`Could not analyze PDF for template variables: ${analysisError.message}`);
      }
    } else if (['.docx', '.doc'].includes(fileExtension)) {
      // Process DOCX/DOC file with template data
      try {
        // First analyze the document
        const analysis = await documentProcessor.analyzeDocumentForSignatureFields(filePath);
        
        // Process template with data if provided
        if (Object.keys(templateData).length > 0) {
          try {
            // Use our specialized Adobe Sign tag handler to process the document
            const processResult = await adobeSignTagHandler.processDocumentWithTags(filePath, templateData);
            
            // Update document data with paths and processing info
            processedFilePath = processResult.processedFilePath;
            finalPdfPath = processResult.pdfFilePath;
            documentData.processedFilePath = processedFilePath;
            documentData.pdfFilePath = finalPdfPath;
            documentData.hasAdobeSignTags = processResult.hasAdobeSignTags;
          } catch (processingError) {
            logger.error(`Error processing document with tags: ${processingError.message}`);
            return next(new ApiError(400, `Error processing document template: ${processingError.message}`));
          }
        } else {
          // No template data, just convert the original document to PDF
          finalPdfPath = await documentProcessor.convertDocxToPdf(filePath);
          documentData.pdfFilePath = finalPdfPath;
        }
        
        documentData.templateVariables = analysis.templateVariables;
        documentData.documentAnalysis = analysis;
        
        // Analyze the converted PDF
        const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
        pageCount = pdfInfo.pageCount;
        
        // Check if the document has Adobe Sign text tags and verify their format
        if (documentData.autoDetectedSignatureFields && documentData.autoDetectedSignatureFields.length > 0) {
          const verificationResult = verifyAdobeSignTextTags(documentData.autoDetectedSignatureFields);
          if (verificationResult.hasTags) {
            logger.info('Adobe Sign text tags detected in document');
            
            if (!verificationResult.correctFormat) {
              logger.warn('Issues found with Adobe Sign text tags:');
              verificationResult.issuesFound.forEach(issue => logger.warn(`- ${issue}`));
              logger.warn('Recommendations:');
              verificationResult.recommendations.forEach(rec => logger.warn(`- ${rec}`));
              
              // If there are issues, add a message to the response
              documentData.textTagIssues = verificationResult.issuesFound;
              documentData.textTagRecommendations = verificationResult.recommendations;
            } else {
              logger.info('Adobe Sign text tags verification passed - signatures should appear at tag positions');
            }
            
            documentData.hasAdobeSignTags = true;
          }
        }
        
        logger.info(`Document processed successfully. Found ${analysis.templateVariables.length} template variables`);
      } catch (processingError) {
        logger.error(`Error processing document: ${processingError.message}`);
        
        // Check if this might be an Adobe Sign tag related error
        // The specific error you're seeing is "Template Error: Multi error"
        if (processingError.message.includes('Multi error') || 
            processingError.message.includes('Template Error') ||
            processingError.message.includes('unopened tag') ||
            processingError.message.includes('unclosed tag') ||
            processingError.message.includes('Error: {')) {
          
          try {
            logger.info('Detected potential Adobe Sign tag related error, checking document');
            // Check for Adobe Sign tags in the document
            const hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(filePath);
            
            if (hasAdobeSignTags) {
              logger.info('Adobe Sign tags detected, using specialized processing instead');
              
              // Use the specialized handler for Adobe Sign tags
              processedFilePath = await documentProcessor.processDocumentWithAdobeSignTags(filePath, templateData);
              documentData.processedFilePath = processedFilePath;
              documentData.hasAdobeSignTags = true;
              
              // Convert processed document to PDF
              finalPdfPath = await documentProcessor.convertDocxToPdf(processedFilePath);
              documentData.pdfFilePath = finalPdfPath;
              
              // Analyze the converted PDF
              const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
              pageCount = pdfInfo.pageCount;
              
              logger.info('Successfully recovered from template error using Adobe Sign handler');
            } else {
              // If not Adobe Sign tags, re-throw original error
              throw processingError;
            }
          } catch (recoveryError) {
            if (recoveryError !== processingError) {
              logger.error(`Recovery attempt failed: ${recoveryError.message}`);
            }
            return next(new ApiError(400, `Error processing document template: ${processingError.message}`));
          }
        } else {
          return next(new ApiError(400, `Error processing document: ${processingError.message}`));
        }
      }
    } else {
      return next(new ApiError(400, 'Unsupported file format. Only PDF, DOCX, and DOC files are allowed'));
    }
    
    documentData.pageCount = pageCount;
    
    // Create document record in database
    const document = await Document.create(documentData);
    
    // Log document upload
    await Log.create({
      level: 'info',
      message: `Document uploaded with template data: ${originalname}`,
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,
      requestMethod: req.method,
      metadata: {
        fileSize: size,
        mimeType: mimetype,
        templateVariables: documentData.templateVariables || [],
        templateDataKeys: Object.keys(templateData),
        autoDetectedFields: documentData.autoDetectedSignatureFields?.length || 0,
        hasProcessedFile: !!processedFilePath,
        containsAdobeSignTags: true
      }
    });
    
    logger.info(`Document uploaded with template data: ${originalname}`);
    
    res.status(201).json(formatResponse(
      201,
      'Document uploaded and processed successfully (with Adobe Sign tags)',
      { 
        document,
        templateVariables: documentData.templateVariables || [],
        templateDataApplied: Object.keys(templateData),
        autoDetectedSignatureFields: documentData.autoDetectedSignatureFields || [],
        processedWithTemplateData: Object.keys(templateData).length > 0,
        containsAdobeSignTags: true
      }
    ));
    
    return; // End function execution here - we've sent the response
  } catch (error) {
    next(error);
  }
};

/**
 * Upload a document from a URL with optional JSON data for template processing
 * @route POST /api/documents/upload-from-url
 */
exports.uploadDocumentFromUrl = async (req, res, next) => {
  try {
    const { documentUrl } = req.body;
    
    if (!documentUrl) {
      return next(new ApiError(400, 'Document URL is required'));
    }
    
    // Download document from URL
    let documentFile;
    try {
      documentFile = await urlUtils.validateAndDownloadUrl(documentUrl);
    } catch (downloadError) {
      logger.error(`Error downloading document: ${downloadError.message}`);
      
      // Determine type of error for more specific error messages
      if (downloadError.message.includes('socket hang up') || 
          downloadError.message.includes('Socket error') || 
          downloadError.message.includes('ECONNRESET') || 
          downloadError.message.includes('No response received')) {
        return next(new ApiError(502, 'Connection to document server was lost. The server might have dropped the connection or had a network error. Please try again or use a different URL.'));
      } else if (downloadError.message.includes('ENOTFOUND')) {
        return next(new ApiError(400, 'Server not found. Please check the URL and your network connection.'));
      } else if (downloadError.message.includes('timed out') || downloadError.message.includes('timeout')) {
        return next(new ApiError(408, 'Request timed out while downloading the document. The server might be slow or the file might be too large. Try a more responsive server or upload the file directly.'));
      } else if (downloadError.message.includes('Invalid URL') || downloadError.message.includes('could not parse URL')) {
        return next(new ApiError(400, 'Invalid URL format. Please provide a valid HTTP or HTTPS URL.'));
      } else if (downloadError.message.includes('socket timeout')) {
        return next(new ApiError(504, 'Gateway timeout. The connection was idle for too long. Try again or use a different server.'));
      } else if (downloadError.message.includes('maxContentLength') || downloadError.message.includes('maxBodyLength')) {
        return next(new ApiError(413, 'Document is too large. Maximum file size is 25MB. Please upload a smaller document or use the direct upload method.'));
      }
      
      return next(new ApiError(500, `Error downloading document: ${downloadError.message}`));
    }
    
    // Initialize document data
    let documentData = {
      filename: documentFile.filename,
      originalName: documentFile.originalName,
      fileSize: documentFile.size,
      filePath: documentFile.path,
      mimeType: documentFile.mimetype,
      status: 'uploaded'
    };
    
    // Check if JSON files were uploaded
    let templateData = {};
    if (req.files && req.files.jsonData) {
      // Process and combine all JSON files
      try {
        templateData = await urlUtils.processJsonFiles(req.files.jsonData);
        documentData.hasTemplateData = true;
      } catch (jsonError) {
        logger.error(`Error processing JSON files: ${jsonError.message}`);
        return next(new ApiError(400, `Error processing JSON data: ${jsonError.message}`));
      }
    } else if (req.body.jsonData) {
      // If JSON data was provided in the request body as a string
      try {
        templateData = typeof req.body.jsonData === 'string' 
          ? JSON.parse(req.body.jsonData) 
          : req.body.jsonData;
        documentData.hasTemplateData = true;
      } catch (error) {
        logger.error(`Error parsing JSON data: ${error.message}`);
        return next(new ApiError(400, 'Invalid JSON data format'));
      }
    }
    
    // Check if it's a PDF or needs processing
    const fileExtension = path.extname(documentFile.originalName).toLowerCase();
    let finalPdfPath = documentFile.path;
    let pageCount = 0;
    
    logger.info(`Processing uploaded document: ${documentFile.originalName} (${fileExtension}) from URL: ${documentUrl}`);
    logger.info(`File mime type: ${documentFile.mimetype}, size: ${documentFile.size} bytes`);
    
    // Validate the file exists and is readable
    try {
      const fileStats = fs.statSync(documentFile.path);
      logger.info(`File stats: size=${fileStats.size}, isFile=${fileStats.isFile()}`);
      
      if (fileStats.size === 0) {
        logger.error('Downloaded file is empty (0 bytes)');
        return next(new ApiError(400, 'Downloaded file is empty. The URL may not point to a valid document or access might be restricted.'));
      }
      
      // Identify the actual file format using file signatures
      const formatInfo = await documentProcessor.identifyFileFormat(documentFile.path);
      logger.info(`File format detection: ${formatInfo.detected} (confidence: ${formatInfo.confidence})`);
      
      // If detected format is different from extension with high confidence, use the detected format
      if (formatInfo.confidence >= 0.8 && formatInfo.detected !== fileExtension) {
        logger.warn(`File extension mismatch: Extension is ${fileExtension} but detected format is ${formatInfo.detected}`);
        
        // Rename the file with the correct extension if needed
        if (['.docx', '.doc', '.pdf'].includes(formatInfo.detected)) {
          const newPath = documentFile.path + formatInfo.detected;
          fs.renameSync(documentFile.path, newPath);
          documentFile.path = newPath;
          documentFile.originalName = path.basename(documentFile.originalName, fileExtension) + formatInfo.detected;
          documentData.filename = path.basename(newPath);
          documentData.originalName = documentFile.originalName;
          documentData.filePath = newPath;
          
          logger.info(`Renamed file with correct extension: ${newPath}`);
        }
      }
    } catch (statError) {
      logger.error(`Error accessing downloaded file: ${statError.message}`);
      return next(new ApiError(500, `Error accessing downloaded file: ${statError.message}`));
    }
    
    // Get the possibly updated extension
    const updatedExtension = path.extname(documentFile.path).toLowerCase();
    
    // Handle file based on detected extension
    if (updatedExtension === '.pdf' || fileExtension === '.pdf') {
      // For PDFs, extract page count
      try {
        pageCount = await documentUtils.getPdfPageCount(documentFile.path);
        documentData.pageCount = pageCount;
        logger.info(`PDF page count: ${pageCount}`);
      } catch (error) {
        logger.error(`Error getting PDF page count: ${error.message}`);
        // Continue with pageCount=0 instead of failing the whole request
        pageCount = 0;
        documentData.pageCount = 0;
        documentData.pageCountError = error.message;
      }
    } else if (['.docx', '.doc'].includes(updatedExtension) || ['.docx', '.doc'].includes(fileExtension)) {
      // For Word documents, process with template data if available
      if (Object.keys(templateData).length > 0) {
        try {
          logger.info('Processing Word document with template data');
          let processedFilePath;
          
          try {
            // First try normal template processing
            processedFilePath = await documentProcessor.processDocumentTemplate(documentFile.path, templateData);
          } catch (templateError) {
            // If we get "Multi error" or other template-related errors, it might be due to Adobe Sign tags
            if (templateError.message.includes('Multi error') || 
                templateError.message.includes('Template Error') ||
                templateError.message.includes('unopened tag') ||
                templateError.message.includes('unclosed tag')) {
              
              logger.info('Template processing failed, checking for Adobe Sign tags');
              
              // Check if document contains Adobe Sign tags
              const hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(documentFile.path);
              
              if (hasAdobeSignTags) {
                logger.info('Adobe Sign tags detected, using specialized processing');
                processedFilePath = await documentProcessor.processDocumentWithAdobeSignTags(documentFile.path, templateData);
              } else {
                // If no Adobe Sign tags found, try direct conversion without template processing
                logger.warn('No Adobe Sign tags found but template processing failed. Using direct conversion without processing.');
                processedFilePath = documentFile.path;
              }
            } else {
              // For other errors, re-throw
              throw templateError;
            }
          }
          
          documentData.processedFilePath = processedFilePath;
          
          // Convert to PDF
          const convertedFilePath = processedFilePath.replace(/\.(docx|doc)$/, '_converted.pdf');
          await documentProcessor.convertToPdf(processedFilePath, convertedFilePath);
          finalPdfPath = convertedFilePath;
          
          // Get PDF page count
          try {
            pageCount = await documentUtils.getPdfPageCount(finalPdfPath);
            documentData.pageCount = pageCount;
            documentData.convertedFilePath = finalPdfPath;
            
            logger.info(`Document processed and converted to PDF with ${pageCount} pages`);
          } catch (pageCountError) {
            logger.error(`Error getting PDF page count: ${pageCountError.message}`);
            // Continue with pageCount=0 instead of failing
            pageCount = 0;
            documentData.pageCount = 0;
            documentData.pageCountError = pageCountError.message;
            documentData.convertedFilePath = finalPdfPath;
            
            logger.info(`Document processed and converted to PDF, but couldn't determine page count`);
          }
        } catch (error) {
          logger.error(`Error processing document: ${error.message}`);
          
          // Provide more detailed error information for debugging
          if (error.properties) {
            logger.error(`Error details: ${JSON.stringify(error.properties)}`);
          }
          
          // Check if it's a template-related error that we might be able to recover from
          if (error.message.includes('Multi error') || 
              error.message.includes('Template Error') ||
              error.message.includes('unopened tag') ||
              error.message.includes('unclosed tag')) {
            
            try {
              // Try direct conversion without template processing as a fallback
              logger.info('Attempting direct PDF conversion without template processing');
              const convertedFilePath = documentFile.path.replace(/\.(docx|doc)$/, '_fallback_converted.pdf');
              await documentProcessor.convertToPdf(documentFile.path, convertedFilePath);
              finalPdfPath = convertedFilePath;
              
              // Get PDF page count
              try {
                pageCount = await documentUtils.getPdfPageCount(finalPdfPath);
                documentData.pageCount = pageCount;
                documentData.convertedFilePath = finalPdfPath;
                documentData.processingError = error.message;
                documentData.usedFallbackConversion = true;
                
                logger.info(`Fallback conversion successful: ${pageCount} pages`);
                
                // Continue with document creation instead of returning error
              } catch (pageCountError) {
                logger.error(`Error getting PDF page count for fallback: ${pageCountError.message}`);
                // Continue with pageCount=0 instead of failing
                pageCount = 0;
                documentData.pageCount = 0;
                documentData.pageCountError = pageCountError.message;
                documentData.convertedFilePath = finalPdfPath;
                documentData.processingError = error.message;
                documentData.usedFallbackConversion = true;
                
                logger.info(`Fallback conversion successful, but couldn't determine page count`);
              }
            } catch (fallbackError) {
              logger.error(`Fallback conversion also failed: ${fallbackError.message}`);
              return next(new ApiError(500, `Document processing failed and fallback conversion also failed. Original error: ${error.message}, Fallback error: ${fallbackError.message}`));
            }
          } else {
            return next(new ApiError(500, `Error processing document: ${error.message}`));
          }
        }
      } else {
        // Convert to PDF without processing
        try {
          logger.info(`Converting ${fileExtension} document to PDF without template processing`);
          
          // First check if it has Adobe Sign tags that might need special handling
          const hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(documentFile.path);
          
          if (hasAdobeSignTags) {
            logger.info('Document contains Adobe Sign tags, using optimized conversion');
          }
          
          const convertedFilePath = documentFile.path.replace(/\.(docx|doc)$/, '_converted.pdf');
          await documentProcessor.convertToPdf(documentFile.path, convertedFilePath);
          finalPdfPath = convertedFilePath;
          
          // Get PDF page count
          try {
            pageCount = await documentUtils.getPdfPageCount(finalPdfPath);
            documentData.pageCount = pageCount;
            documentData.convertedFilePath = finalPdfPath;
            
            logger.info(`Document converted to PDF with ${pageCount} pages`);
          } catch (pageCountError) {
            logger.error(`Error getting PDF page count: ${pageCountError.message}`);
            // Continue with pageCount=0 instead of failing
            pageCount = 0;
            documentData.pageCount = 0;
            documentData.pageCountError = pageCountError.message;
            documentData.convertedFilePath = finalPdfPath;
            
            logger.info(`Document converted to PDF, but couldn't determine page count`);
          }
        } catch (error) {
          logger.error(`Error converting document to PDF: ${error.message}`);
          return next(new ApiError(500, `Error converting document to PDF: ${error.message}`));
        }
      }
    } else {
      // For any other format, attempt conversion to PDF
      try {
        logger.info(`Attempting to convert unknown format document (${fileExtension}) to PDF`);
        const convertedFilePath = documentFile.path + '_converted.pdf';
        await documentProcessor.convertToPdf(documentFile.path, convertedFilePath);
        finalPdfPath = convertedFilePath;
        
        // Get PDF page count
        try {
          pageCount = await documentUtils.getPdfPageCount(finalPdfPath);
          documentData.pageCount = pageCount;
          documentData.convertedFilePath = finalPdfPath;
          
          logger.info(`Document converted to PDF with ${pageCount} pages`);
        } catch (pageCountError) {
          logger.error(`Error getting PDF page count: ${pageCountError.message}`);
          // Continue with pageCount=0 instead of failing
          pageCount = 0;
          documentData.pageCount = 0;
          documentData.pageCountError = pageCountError.message;
          documentData.convertedFilePath = finalPdfPath;
          
          logger.info(`Document converted to PDF, but couldn't determine page count`);
        }
      } catch (error) {
        logger.error(`Error converting document to PDF: ${error.message}`);
        return next(new ApiError(400, `Unsupported file format (${fileExtension}). Only PDF, DOCX, and DOC files are allowed. Conversion failed: ${error.message}`));
      }
    }
    
    // Create document in database
    const document = new Document({
      ...documentData,
      templateData: Object.keys(templateData).length > 0 ? templateData : undefined,
      createdBy: req.apiKey.userId || req.apiKey._id
    });
    
    await document.save();
    
    // Create log entry
    const logEntry = new Log({
      level: 'info',
      message: `Document uploaded from URL: ${documentUrl}`,
      metadata: {
        action: 'document_upload_from_url',
        filename: document.filename,
        originalName: document.originalName,
        fileSize: document.fileSize,
        source: 'url',
        url: documentUrl
      },
      documentId: document._id,
      userId: req.apiKey.userId || req.apiKey._id
    });
    
    await logEntry.save();
    
    res.status(201).json(formatResponse(
      201,
      'Document uploaded successfully from URL',
      {
        document: {
          id: document._id,
          filename: document.filename,
          originalName: document.originalName,
          status: document.status,
          pageCount: document.pageCount || 0,
          hasTemplateData: !!document.templateData
        }
      }
    ));
  } catch (error) {
    logger.error(`Error uploading document from URL: ${error.message}`);
    next(new ApiError(500, `Error uploading document from URL: ${error.message}`));
  }
};

/**
 * Get all documents for a user
 * @route GET /api/documents
 */
exports.getDocuments = async (req, res, next) => {
  try {
    const documents = await Document.find({})
      .sort({ createdAt: -1 });
    
    res.status(200).json(formatResponse(
      200,
      'Documents retrieved successfully',
      { documents }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Get a specific document
 * @route GET /api/documents/:id
 */
exports.getDocument = async (req, res, next) => {
  try {
    const document = await Document.findOne({ 
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }
    
    res.status(200).json(formatResponse(
      200,
      'Document retrieved successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Prepare document for e-signature
 * @route POST /api/documents/:id/prepare
 */
exports.prepareForSignature = async (req, res, next) => {
  try {
    let { recipients, signatureFieldMapping, signingFlow } = req.body;
    
    const document = await Document.findOne({
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }

    // If no recipients provided, try to extract from JSON template data
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {
      if (document.templateData) {
        logger.info('No recipients provided, extracting from template data');
        recipients = extractRecipientsFromTemplateData(document.templateData);
        
        if (!recipients || recipients.length === 0) {
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));
        }
        logger.info(`Extracted ${recipients.length} recipients from template data`);
        
        // Auto-generate signature field mapping from extracted recipients
        if (!signatureFieldMapping) {
          signatureFieldMapping = {};
          recipients.forEach(recipient => {
            if (recipient.signatureField) {
              signatureFieldMapping[recipient.email] = recipient.signatureField;
            }
          });
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);
        }
      } else {
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));
      }
    } else if (!Array.isArray(recipients)) {
      return next(new ApiError(400, 'Recipients must be an array'));
    }
    
    // Validate signing flow option
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) 
      ? signingFlow.toUpperCase() 
      : 'SEQUENTIAL'; // Default to sequential (updated default)
    
    // Validate and format recipients
    const formattedRecipients = recipients.map((recipient, index) => {
      if (!recipient.name || !recipient.email) {
        throw new ApiError(400, 'Each recipient must have a name and email');
      }
      
      return {
        name: recipient.name,
        email: recipient.email,
        order: index + 1,
        status: 'pending',
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`
      };
    });
    
    // Update document with recipients and signature field mapping
    document.recipients = formattedRecipients;
    document.status = 'ready_for_signature';
    document.signatureFieldMapping = signatureFieldMapping || {};
    document.signingFlow = selectedSigningFlow;
    await document.save();
    
    // Log document preparation
    await Log.create({
      level: 'info',
      message: `Document prepared for signature: ${document.originalName}`,
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,
      requestMethod: req.method,
      metadata: {
        recipientCount: recipients.length
      }
    });
    
    logger.info(`Document prepared for signature: ${document.originalName}`);
    
    res.status(200).json(formatResponse(
      200,
      'Document prepared for signature successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Send document for e-signature using the best approach
 * @route POST /api/documents/:id/send
 */
exports.sendForSignature = async (req, res, next) => {
  try {
    // First validate Adobe Sign configuration
    const { validateAdobeSignConfig } = require('../config/adobeSign');
    const configValidation = validateAdobeSignConfig();
    
    if (!configValidation.isValid) {
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));
    }
    
    const document = await Document.findOne({
      _id: req.params.id,
      status: 'ready_for_signature'
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found or not ready for signature'));
    }

    if (!document.recipients || document.recipients.length === 0) {
      return next(new ApiError(400, 'Document has no recipients'));
    }
    
    // Validate recipient emails
    const invalidRecipients = document.recipients.filter(recipient => {
      const email = recipient.email;
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    });
    
    if (invalidRecipients.length > 0) {
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));
    }

    try {
      // Determine which file to use for Adobe Sign
      let fileToUpload = document.filePath;
      
      // If document was processed from DOCX/DOC, use the PDF version
      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {
        fileToUpload = document.pdfFilePath;
        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);
      }
      
      // Check if file exists
      if (!fs.existsSync(fileToUpload)) {
        logger.error(`File not found at path: ${fileToUpload}`);
        return next(new ApiError(404, 'Document file not found on server'));
      }
      
      // Get file stats to ensure it's not empty
      const fileStats = fs.statSync(fileToUpload);
      if (fileStats.size === 0) {
        logger.error(`File is empty: ${fileToUpload}`);
        return next(new ApiError(400, 'Document file is empty'));
      }
      
      // Upload as transient document
      logger.info(`Uploading document as transient document: ${document.originalName}`);
      const transientDocumentId = await uploadTransientDocument(fileToUpload);
      logger.info(`Document uploaded as transient document: ${transientDocumentId}`);
      
      // Ensure we have a webhook setup for status updates
      try {
        // Get access token
        const accessToken = await getAccessToken();
        
        // Setup webhook URL
        const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;
        
        // Create webhook if necessary
        if (webhookUrl) {
          await createWebhook(accessToken, webhookUrl);
          logger.info(`Webhook setup for Adobe Sign: ${webhookUrl}`);
        } else {
          logger.warn('No webhook URL configured for Adobe Sign updates');
        }
      } catch (webhookError) {
        // Log the error but continue with document sending
        logger.error(`Error setting up webhook: ${webhookError.message}`);
      }
      
      // Use the comprehensive approach from adobeSignFormFields utility
      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);
      const result = await createAgreementWithBestApproach(
        transientDocumentId,
        document.recipients,
        document.originalName,
        {
          templateId: document.templateId, // If using templates
          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],
          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)
        }
      );
      
      // Update document with Adobe Sign agreement ID
      document.adobeAgreementId = result.agreementId;
      document.status = 'sent_for_signature';
      document.adobeMetadata = {
        agreementId: result.agreementId,
        method: result.method,
        createdAt: new Date()
      };
      
      // Update recipients status
      document.recipients.forEach(recipient => {
        recipient.status = 'sent';
      });
      
      await document.save();
      
      // Log document sent for signature
      await Log.create({
        level: 'info',
        message: `Document sent for signature using ${result.method} approach: ${document.originalName}`,
        
        documentId: document._id,
        ipAddress: req.ip,
        requestPath: req.originalUrl,
        requestMethod: req.method,
        metadata: {
          adobeAgreementId: result.agreementId,
          method: result.method,
          recipientCount: document.recipients.length
        }
      });
      
      logger.info(`Document sent for signature using ${result.method} approach: ${document.originalName} `);
      
      res.status(200).json(formatResponse(
        200,
        `Document sent for signature successfully using ${result.method} approach`,
        { 
          document,
          adobeAgreementId: result.agreementId,
          method: result.method
        }
      ));
    } catch (adobeError) {
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);
      if (adobeError.response) {
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);
      }
      
      // Update document status to indicate error
      document.status = 'signature_error';
      document.errorMessage = adobeError.message;
      await document.save();
      
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`));
    }
  } catch (error) {
    next(error);
  }
};

/**
 * Check document status from Adobe Sign
 * @route GET /api/documents/:id/status
 */
exports.checkDocumentStatus = async (req, res, next) => {
  try {
    const document = await Document.findOne({
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }
    
    if (!document.adobeAgreementId) {
      return next(new ApiError(400, 'Document has not been sent for signature yet'));
    }
    
    try {
      // Get Adobe Sign client (async)
      const adobeSignClient = await createAdobeSignClient();
      
      // Get agreement status
      const agreementResponse = await adobeSignClient.get(`api/rest/v6/agreements/${document.adobeAgreementId}`);
      
      // Update document metadata
      document.adobeMetadata = agreementResponse.data;
      
      // Try to get form field data to check for actual signatures
      let formFieldData = null;
      try {
        const formFieldResponse = await adobeSignClient.get(`api/rest/v6/agreements/${document.adobeAgreementId}/formData`);
        formFieldData = formFieldResponse.data;
        logger.info(`Retrieved form field data for agreement ${document.adobeAgreementId}`);
      } catch (formFieldError) {
        logger.warn(`Could not retrieve form field data: ${formFieldError.message}`);
      }
      
      // Try to get agreement events to check for signature events
      let agreementEvents = null;
      try {
        const eventsResponse = await adobeSignClient.get(`api/rest/v6/agreements/${document.adobeAgreementId}/events`);
        agreementEvents = eventsResponse.data;
        logger.info(`Retrieved agreement events for agreement ${document.adobeAgreementId}`);
      } catch (eventsError) {
        logger.warn(`Could not retrieve agreement events: ${eventsError.message}`);
      }
      
      // Get signing URLs for all recipients
      let signingUrls = {};
      try {
        const signingUrlResponse = await adobeSignClient.get(`api/rest/v6/agreements/${document.adobeAgreementId}/signingUrls`);
        const signingUrlSets = signingUrlResponse.data.signingUrlSetInfos || [];
        
        // Flatten the signing URLs by recipient email
        signingUrlSets.forEach(urlSet => {
          (urlSet.signingUrls || []).forEach(urlInfo => {
            if (urlInfo.email && urlInfo.esignUrl) {
              signingUrls[urlInfo.email.toLowerCase()] = urlInfo.esignUrl;
            }
          });
        });
        
        logger.info(`Retrieved signing URLs for ${Object.keys(signingUrls).length} recipients`);
      } catch (urlError) {
        logger.warn(`Could not retrieve signing URLs: ${urlError.message}`);
      }
      
      // Update recipients status using multiple data sources
      if (agreementResponse.data.participantSetsInfo) {
        agreementResponse.data.participantSetsInfo.forEach(participantSet => {
          participantSet.memberInfos.forEach(member => {
            const recipient = document.recipients.find(r => r.email === member.email);
            
            if (recipient) {
              // Log the member status for debugging
              logger.info(`Checking recipient ${member.email} - Adobe Sign status: ${member.status}`);
              
              // Store the previous status to detect changes
              const previousStatus = recipient.status;
              
              // Check if this recipient has actually signed by looking at different data sources
              let hasActuallySigned = false;
              
              // Method 1: Check form field data for signatures
              if (formFieldData && Array.isArray(formFieldData)) {
                const recipientSignatures = formFieldData.filter(field => 
                  field.fieldType === 'SIGNATURE' && 
                  field.value && 
                  field.value.trim() !== '' &&
                  (field.assignedToRecipient === member.email || field.name.includes(`signer${participantSet.order}`))
                );
                
                if (recipientSignatures.length > 0) {
                  hasActuallySigned = true;
                  logger.info(`Recipient ${member.email} has signature in form field data`);
                }
              } else if (formFieldData && formFieldData.fields && Array.isArray(formFieldData.fields)) {
                // Handle different API response format
                const recipientSignatures = formFieldData.fields.filter(field => 
                  field.fieldType === 'SIGNATURE' && 
                  field.value && 
                  field.value.trim() !== '' &&
                  (field.assignedToRecipient === member.email || field.name.includes(`signer${participantSet.order}`))
                );
                
                if (recipientSignatures.length > 0) {
                  hasActuallySigned = true;
                  logger.info(`Recipient ${member.email} has signature in form field data (fields format)`);
                }
              } else if (formFieldData) {
                // Log the structure for debugging
                logger.info(`CheckStatus - Form field data structure: ${JSON.stringify(Object.keys(formFieldData), null, 2)}`);
              }
              
              // Method 2: Check agreement events for ESIGNED events
              if (agreementEvents && agreementEvents.events) {
                const signatureEvents = agreementEvents.events.filter(event => 
                  event.type === 'ESIGNED' && 
                  event.participantEmail === member.email
                );
                
                if (signatureEvents.length > 0) {
                  hasActuallySigned = true;
                  logger.info(`Recipient ${member.email} has ESIGNED event in agreement events`);
                  
                  // Update signedAt timestamp from the event
                  if (!recipient.signedAt && signatureEvents[0].date) {
                    recipient.signedAt = new Date(signatureEvents[0].date);
                    logger.info(`Updated signedAt timestamp for ${member.email} from event data`);
                  }
                }
              }
              
              // Method 3: Check Adobe Sign status directly
              // IMPORTANT: This is a critical check for the "stays active" issue
              if (member.status === 'SIGNED') {
                hasActuallySigned = true;
                logger.info(`Recipient ${member.email} has SIGNED status in Adobe Sign`);
                
                // Update signedAt if we don't have it yet
                if (!recipient.signedAt) {
                  recipient.signedAt = new Date();
                  logger.info(`Set signedAt timestamp for ${member.email} based on SIGNED status`);
                }
              }
              
              // Method 4: Check if already marked as signed locally
              if (recipient.signedAt) {
                hasActuallySigned = true;
                logger.info(`Recipient ${member.email} has local signedAt timestamp`);
              }
              
              // Now update the status based on actual signature detection
              if (hasActuallySigned) {
                recipient.status = 'signed';
                if (!recipient.signedAt) {
                  recipient.signedAt = new Date();
                }
                logger.info(`✅ Recipient ${member.email} confirmed as SIGNED`);
              } else {
                // They haven't actually signed yet
                switch (member.status) {
                  case 'SIGNED':
                    // Adobe says signed but we found no evidence - this shouldn't happen
                    // But we'll trust Adobe Sign in this case
                    logger.warn(`⚠️ Adobe Sign says ${member.email} is SIGNED but no signature evidence found`);
                    recipient.status = 'signed';
                    if (!recipient.signedAt) {
                      recipient.signedAt = new Date();
                    }
                    break;
                  case 'REJECTED':
                  case 'DECLINED':
                    recipient.status = 'declined';
                    break;
                  case 'EXPIRED':
                    recipient.status = 'expired';
                    break;
                  case 'NOT_YET_ACTED':
                    if (member.privateMessage === 'viewed') {
                      recipient.status = 'viewed';
                    } else {
                      recipient.status = 'sent';
                    }
                    break;
                  case 'ACTIVE':
                    // Fix for "active" even after signing issue
                    // Double-check against other data sources
                    if (hasActuallySigned) {
                      recipient.status = 'signed';
                      if (!recipient.signedAt) {
                        recipient.signedAt = new Date();
                      }
                      logger.info(`⚠️ Recipient ${member.email} shows ACTIVE but evidence indicates SIGNED - correcting status`);
                    } else {
                      // Check if we have a form field signature but Adobe Sign doesn't know yet
                      if (formFieldData && Array.isArray(formFieldData)) {
                        const recipientSignatures = formFieldData.filter(field => 
                          field.fieldType === 'SIGNATURE' && 
                          field.value && 
                          field.value.trim() !== '' &&
                          (field.assignedToRecipient === member.email || field.name.includes(`signer${participantSet.order}`))
                        );
                        
                        if (recipientSignatures.length > 0) {
                          // They actually signed based on form data
                          recipient.status = 'signed';
                          if (!recipient.signedAt) {
                            recipient.signedAt = new Date();
                          }
                          logger.info(`⚠️ Recipient ${member.email} shows ACTIVE but form field evidence indicates SIGNED - correcting status`);
                        } else {
                          recipient.status = 'sent';
                          logger.info(`📝 Recipient ${member.email} is ACTIVE and ready to sign`);
                        }
                      } else {
                        recipient.status = 'sent';
                        logger.info(`📝 Recipient ${member.email} is ACTIVE and ready to sign`);
                      }
                    }
                    break;
                  case 'WAITING_FOR_OTHERS':
                    recipient.status = 'waiting';
                    logger.info(`⏳ Recipient ${member.email} is waiting for others to sign first`);
                    break;
                  case 'WAITING_FOR_MY_SIGNATURE':
                  case 'WAITING_FOR_VERIFICATION':
                  case 'WAITING_FOR_FAXING':
                    recipient.status = 'waiting';
                    break;
                  case 'OUT_FOR_SIGNATURE':
                    recipient.status = 'sent';
                    break;
                  default:
                    logger.warn(`Unknown Adobe Sign status for ${member.email}: ${member.status}`);
                    recipient.status = 'sent'; // Default to sent for unknown statuses
                    break;
                }
              }
              
              // Add signing URL if available
              if (signingUrls[recipient.email.toLowerCase()]) {
                recipient.signingUrl = signingUrls[recipient.email.toLowerCase()];
                logger.info(`Added signing URL for ${recipient.email}`);
              }
              
              logger.info(`Final status for ${member.email}: ${recipient.status} (was: ${previousStatus})`);
            }
          });
        });
      }
      
      // Now update document status based on Adobe Sign status and recipient statuses
      const adobeStatus = agreementResponse.data.status;
      
      // Count signed recipients to properly determine document completion
      const signedCount = document.recipients.filter(r => r.status === 'signed').length;
      const totalRecipients = document.recipients.length;
      
      // Improve document status determination
      const previousDocStatus = document.status;
      
      // First determine status based on Adobe Sign status
      switch (adobeStatus) {
        case 'SIGNED':
          // For SIGNED status, assume completed but verify all recipients have signed
          document.status = 'completed';
          logger.info(`Adobe Sign reports agreement is SIGNED`);
          break;
        case 'CANCELLED':
          document.status = 'cancelled';
          break;
        case 'EXPIRED':
          document.status = 'expired';
          break;
        case 'OUT_FOR_SIGNATURE':
          // Check recipient statuses to determine actual state
          if (signedCount === totalRecipients) {
            // All recipients have signed according to our records
            document.status = 'completed';
            logger.info(`All recipients signed (${signedCount}/${totalRecipients}) but Adobe still shows OUT_FOR_SIGNATURE - marking as completed`);
          } else if (signedCount > 0) {
            document.status = 'partially_signed';
            logger.info(`Document partially signed: ${signedCount}/${totalRecipients} recipients have signed`);
          } else {
            document.status = 'sent_for_signature';
          }
          break;
        case 'COMPLETED':
          document.status = 'completed';
          logger.info(`Adobe Sign reports agreement is COMPLETED`);
          break;
        default:
          // For unknown statuses, use recipient count logic
          if (signedCount === totalRecipients && totalRecipients > 0) {
            document.status = 'completed';
            logger.info(`All recipients signed despite unknown Adobe status (${adobeStatus}) - marking as completed`);
          } else if (signedCount > 0) {
            document.status = 'partially_signed';
            logger.info(`Partially signed with unknown Adobe status (${adobeStatus}): ${signedCount}/${totalRecipients}`);
          }
          logger.info(`Unknown Adobe Sign status: ${adobeStatus}, determined document status: ${document.status}`);
          break;
      }
      
      // ADDITIONAL check specifically for the "still says out for signature" issue
      // If all recipients have signed, the document should be marked as completed
      if (signedCount === totalRecipients && totalRecipients > 0 && document.status !== 'completed') {
        logger.info(`Status override: All recipients (${signedCount}/${totalRecipients}) have signed - marking as completed`);
        document.status = 'completed';
      }
      
      // Track status change for logging
      if (previousDocStatus !== document.status) {
        logger.info(`Document status changed: ${previousDocStatus} -> ${document.status}`);
      }
      
      // Save the updated document
      await document.save();
      
      // Log status check
      await Log.create({
        level: 'info',
        message: `Document status checked: ${document.originalName}`,
        documentId: document._id,
        ipAddress: req.ip,
        requestPath: req.originalUrl,
        requestMethod: req.method,
        metadata: {
          adobeStatus,
          signedCount,
          totalRecipients,
          documentStatus: document.status
        }
      });
      
      logger.info(`Document status checked: ${document.originalName}`);
      
      // Prepare response - include signing URLs for each recipient
      const recipientData = document.recipients.map(recipient => ({
        name: recipient.name,
        email: recipient.email,
        status: recipient.status,
        signedAt: recipient.signedAt,
        signingUrl: recipient.signingUrl || null,
        order: recipient.order
      }));
      
      res.status(200).json(formatResponse(
        200,
        'Document status retrieved successfully',
        { 
          document,
          recipients: recipientData,
          signingProgress: {
            totalRecipients,
            signedCount,
            pendingCount: totalRecipients - signedCount,
            completionPercentage: totalRecipients > 0 ? Math.round((signedCount / totalRecipients) * 100) : 0
          },
          adobeStatus
        }
      ));
    } catch (error) {
      // Handle Adobe Sign API errors
      logger.error(`Error checking document status: ${error.message}`);
      if (error.response) {
        logger.error(`Status: ${error.response.status}, Data: ${JSON.stringify(error.response.data)}`);
      }
      
      return next(new ApiError(500, `Error checking document status: ${error.message}`));
    }
  } catch (error) {
    next(error);
  }
};

/**
 * Send reminder to recipients who haven't signed yet
 * @route POST /api/documents/:id/send-reminder
 */
exports.sendReminder = async (req, res, next) => {
  try {
    const { id } = req.params;
    const { message } = req.body;

    // Find document
    const document = await Document.findById(id);
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }

    // Check if document has Adobe Sign agreement ID
    if (!document.adobeAgreementId) {
      return next(new ApiError(400, 'Document has not been sent for signature yet'));
    }

    // Get the Adobe Sign access token
    const accessToken = await getAccessToken();
    
    // Get agreement details from Adobe Sign using comprehensive method
    let agreementInfo;
    try {
      // Try comprehensive method first for better participant data
      agreementInfo = await getComprehensiveAgreementInfo(accessToken, document.adobeAgreementId);
      
      // Log the full agreement info for debugging
      logger.info(`Full agreement info structure: ${JSON.stringify(agreementInfo, null, 2)}`);
      
      // Check if the agreement is in a state where reminders can be sent
      if (agreementInfo.status !== 'OUT_FOR_SIGNATURE' && 
          agreementInfo.status !== 'OUT_FOR_APPROVAL' && 
          agreementInfo.status !== 'IN_PROCESS') {
        logger.warn(`Agreement is in status ${agreementInfo.status} which may not support reminders`);
        
        if (agreementInfo.status === 'SIGNED' || agreementInfo.status === 'APPROVED') {
          return next(new ApiError(400, 'Document has already been fully signed'));
        } else if (agreementInfo.status === 'CANCELLED') {
          return next(new ApiError(400, 'Document has been cancelled'));
        } else if (agreementInfo.status === 'EXPIRED') {
          return next(new ApiError(400, 'Document has expired'));
        } else if (agreementInfo.status === 'DRAFT') {
          return next(new ApiError(400, 'Document is still in draft state and has not been sent'));
        }
      }
    } catch (error) {
      logger.error(`Error getting comprehensive agreement info: ${error.message}`);
      
      // Fallback to basic agreement info
      try {
        logger.info('Falling back to basic agreement info...');
        agreementInfo = await getAgreementInfo(accessToken, document.adobeAgreementId);
        logger.info(`Fallback agreement info keys: ${Object.keys(agreementInfo || {}).join(', ')}`);
      } catch (fallbackError) {
        logger.error(`Fallback also failed: ${fallbackError.message}`);
        return next(new ApiError(500, `Failed to get agreement info from Adobe Sign: ${error.message}`));
      }
    }

    // Find recipients who haven't signed yet
    const pendingRecipients = [];
    let participantFound = false;
    
    // Check if we have participant data from Adobe Sign
    if (agreementInfo && agreementInfo.participantSets && agreementInfo.participantSets.length > 0) {
      // Debug: Log the entire participant structure
      logger.info(`Agreement participant structure: ${JSON.stringify(agreementInfo.participantSets, null, 2)}`);
      
      for (const participantSet of agreementInfo.participantSets) {
        // Only process SIGNER participant sets (not CC, etc.)
        if (participantSet.role !== 'SIGNER') {
          logger.info(`Skipping non-signer participant set with role: ${participantSet.role}`);
          continue;
        }
        
        for (const participant of participantSet.memberInfos) {
          participantFound = true;
          // Debug: Log individual participant status
          logger.info(`Participant ${participant.email} has status: ${participant.status}`);
          
          // Adobe Sign status meanings:
          // - WAITING_FOR_MY_SIGNATURE: This participant needs to sign
          // - WAITING_FOR_MY_APPROVAL: This participant needs to approve
          // - WAITING_FOR_MY_DELEGATION: This participant needs to delegate
          // - WAITING_FOR_MY_ACCEPTANCE: This participant needs to accept
          // - WAITING_FOR_MY_FORM_FILLING: This participant needs to fill form
          // - WAITING_FOR_OTHERS: This participant is waiting for others to complete
          // - SIGNED: This participant has signed
          // - APPROVED: This participant has approved
          // - ACCEPTED: This participant has accepted
          // - FORM_FILLED: This participant has filled the form
          // - DELEGATED: This participant has delegated to someone else
          // - NOT_YET_VISIBLE: Agreement is not yet visible to this participant
          // - COMPLETED: Agreement is completed for this participant
          
          // Consider a recipient pending if they still need to take action or are waiting
          const isPending = 
            participant.status === 'WAITING_FOR_MY_SIGNATURE' || 
            participant.status === 'WAITING_FOR_MY_APPROVAL' ||
            participant.status === 'WAITING_FOR_MY_DELEGATION' ||
            participant.status === 'WAITING_FOR_MY_ACCEPTANCE' ||
            participant.status === 'WAITING_FOR_MY_FORM_FILLING' ||
            participant.status === 'NOT_YET_VISIBLE' ||
            participant.status === 'WAITING_FOR_OTHERS';
          
          // Consider a recipient completed if they've taken their required action
          const isCompleted = 
            participant.status === 'SIGNED' ||
            participant.status === 'APPROVED' ||
            participant.status === 'ACCEPTED' ||
            participant.status === 'FORM_FILLED' ||
            participant.status === 'DELEGATED' ||
            participant.status === 'COMPLETED' ||
            participant.status === 'DECLINED' ||
            participant.status === 'EXPIRED';
          
          // Add to pending list if the participant still needs to take action
          if (isPending) {
            logger.info(`Found pending recipient: ${participant.email} with status: ${participant.status}`);
            
            pendingRecipients.push({
              email: participant.email,
              name: participant.name || participant.email.split('@')[0],
              status: participant.status,
              actionRequired: participant.status !== 'WAITING_FOR_OTHERS' && participant.status !== 'NOT_YET_VISIBLE'
            });
          } else if (!isCompleted) {
            // Log warning for unexpected status values
            logger.warn(`Participant ${participant.email} has unexpected status: ${participant.status}`);
          }
        }
      }
      
      // If we found participants but none are pending, check if we need to include WAITING_FOR_OTHERS
      if (participantFound && pendingRecipients.length === 0) {
        logger.warn('Found participants but none are in pending status - checking for waiting participants');
        
        // Second pass to include waiting participants if needed
        for (const participantSet of agreementInfo.participantSets) {
          if (participantSet.role === 'SIGNER') {
            for (const participant of participantSet.memberInfos) {
              if (participant.status === 'WAITING_FOR_OTHERS') {
                logger.info(`Including waiting participant in pending list: ${participant.email}`);
                pendingRecipients.push({
                  email: participant.email,
                  name: participant.name || participant.email.split('@')[0],
                  status: participant.status,
                  actionRequired: false
                });
              }
            }
          }
        }
      }
    } else {
      // FALLBACK: If Adobe Sign doesn't return participant data, use our document's recipient list
      logger.warn(`No participant sets found in Adobe Sign response, using document recipients as fallback`);
      logger.info(`Document recipients: ${JSON.stringify(document.recipients, null, 2)}`);
      
      if (document.recipients && document.recipients.length > 0) {
        participantFound = true;
        
        for (const recipient of document.recipients) {
          // If recipient hasn't signed yet (status is not 'signed'), consider them pending
          if (recipient.status !== 'signed' && recipient.status !== 'completed') {
            logger.info(`Found pending recipient from document data: ${recipient.email} with status: ${recipient.status}`);
            
            pendingRecipients.push({
              email: recipient.email,
              name: recipient.name || recipient.email.split('@')[0],
              status: recipient.status || 'WAITING_FOR_MY_SIGNATURE',
              actionRequired: true,
              source: 'document_fallback'
            });
          }
        }
      } else {
        logger.error(`No recipients found in document ${document._id} and no participants from Adobe Sign`);
      }
    }
    
    // Log detailed information for debugging
    logger.info(`Agreement ID: ${document.adobeAgreementId}, Status: ${agreementInfo?.status}`);
    logger.info(`Total participants: ${agreementInfo?.participantSets?.reduce((total, set) => total + set.memberInfos.length, 0) || 0}`);
    logger.info(`Pending recipients found: ${pendingRecipients.length}`);
    
    // If no participants at all, something might be wrong with the agreement
    if (!agreementInfo?.participantSets || agreementInfo.participantSets.length === 0) {
      logger.warn(`No participant sets found in agreement ${document.adobeAgreementId}`);
    }

    // Calculate total participants who are signers
    let totalSigners = 0;
    
    if (agreementInfo?.participantSets && agreementInfo.participantSets.length > 0) {
      // Use Adobe Sign data if available
      totalSigners = agreementInfo.participantSets.reduce((total, set) => 
        set.role === 'SIGNER' ? total + set.memberInfos.length : total, 0) || 0;
    } else if (document.recipients && document.recipients.length > 0) {
      // Fallback to document recipients
      totalSigners = document.recipients.length;
      logger.info(`Using document recipients count as fallback: ${totalSigners}`);
    }
    
    // If we still have no participants but status is OUT_FOR_SIGNATURE, there's likely an issue
    if (totalSigners === 0 && agreementInfo?.status === 'OUT_FOR_SIGNATURE') {
      logger.error(`Agreement ${document.adobeAgreementId} has status OUT_FOR_SIGNATURE but no participants found`);
      logger.error(`Agreement info keys: ${Object.keys(agreementInfo || {}).join(', ')}`);
      
      // Check if participants are in a different field
      if (agreementInfo?.participants) {
        logger.info(`Found participants in different field: ${JSON.stringify(agreementInfo.participants, null, 2)}`);
      }
      if (agreementInfo?.recipientSetInfos) {
        logger.info(`Found recipientSetInfos: ${JSON.stringify(agreementInfo.recipientSetInfos, null, 2)}`);
      }
    }
    
    // Count participants by status
    const participantCounts = {
      total: totalSigners,
      pending: pendingRecipients.length,
      actionRequired: pendingRecipients.filter(r => r.actionRequired).length,
      waiting: pendingRecipients.filter(r => !r.actionRequired).length,
      completed: 0
    };
    
    // Count completed participants
    if (agreementInfo?.participantSets) {
      for (const participantSet of agreementInfo.participantSets) {
        if (participantSet.role === 'SIGNER') {
          for (const participant of participantSet.memberInfos) {
            if (['SIGNED', 'APPROVED', 'ACCEPTED', 'FORM_FILLED', 'DELEGATED', 'COMPLETED'].includes(participant.status)) {
              participantCounts.completed++;
            }
          }
        }
      }
    }
    
    logger.info(`Participant counts: ${JSON.stringify(participantCounts)}`);
    
    if (pendingRecipients.length === 0) {
      // Check if there are actually participants
      if (totalSigners === 0) {
        return res.status(200).json(formatResponse(
          200,
          'No participants found in this agreement',
          { 
            pendingRecipients: [],
            agreementStatus: agreementInfo?.status || 'UNKNOWN',
            totalParticipants: 0,
            participantCounts
          }
        ));
      }
      
      return res.status(200).json(formatResponse(
        200,
        'No pending recipients to send reminder to - all participants have completed their actions',
        { 
          pendingRecipients: [],
          agreementStatus: agreementInfo?.status || 'UNKNOWN',
          totalParticipants: totalSigners,
          participantCounts
        }
      ));
    }

    // Try to send reminder via Adobe Sign API
    let reminderSent = false;
    let reminderError = null;
    
    try {
      logger.info(`Attempting to send reminder for agreement ${document.adobeAgreementId}`);
      
      // Log the access token (partially masked for security)
      const maskedToken = accessToken ? `${accessToken.substring(0, 8)}...${accessToken.substring(accessToken.length - 8)}` : 'null';
      logger.info(`Using access token: ${maskedToken}`);
      
      await sendReminder(
        accessToken, 
        document.adobeAgreementId,
        message || 'Please sign this document at your earliest convenience.'
      );
      
      logger.info(`Successfully sent reminder via Adobe Sign API for agreement ${document.adobeAgreementId}`);
      reminderSent = true;
    } catch (error) {
      logger.error(`Error sending reminder via Adobe Sign API: ${error.message}`);
      
      // Log more detailed error information if available
      if (error.response) {
        logger.error(`Adobe Sign API response status: ${error.response.status}`);
        logger.error(`Adobe Sign API response data: ${JSON.stringify(error.response.data || {})}`);
      }
      
      reminderError = error.message;
      // We'll continue anyway to return the list of pending recipients
    }

    // Create log entry
    const logEntry = new Log({
      level: 'info',
      message: `Reminder sent for document ${document._id}`,
      action: 'send_reminder',
      documentId: document._id,
      userId: req.apiKey.userId || req.apiKey._id,
      details: {
        pendingRecipients: pendingRecipients.map(r => r.email),
        reminderSent,
        reminderError,
        message: message || 'Default reminder message'
      }
    });
    
    await logEntry.save();
    
    // Send emails directly as a backup if Adobe Sign API failed
    if (!reminderSent && pendingRecipients.length > 0) {
      try {
        for (const recipient of pendingRecipients) {
          await emailService.sendReminderEmail({
            to: recipient.email,
            name: recipient.name,
            documentName: document.originalName,
            message: message || 'Please sign this document at your earliest convenience.',
            documentId: document._id
          });
        }
        logger.info(`Sent backup reminder emails to ${pendingRecipients.length} recipients`);
      } catch (emailError) {
        logger.error(`Error sending backup reminder emails: ${emailError.message}`);
      }
    }
    
    // Return response
    res.status(200).json(formatResponse(
      200,
      reminderSent 
        ? `Reminder sent successfully to ${pendingRecipients.length} recipient(s)` 
        : `Found ${pendingRecipients.length} pending recipient(s), but reminder could not be sent via Adobe Sign`,
      {
        pendingRecipients: pendingRecipients.map(r => ({
          email: r.email,
          name: r.name,
          status: r.status,
          actionRequired: r.actionRequired
        })),
        participantCounts,
        reminderSent,
        reminderError,
        adobeSignInfo: {
          agreementId: document.adobeAgreementId,
          status: agreementInfo?.status || 'UNKNOWN',
          participantCount: totalSigners,
          participantStatuses: agreementInfo?.participantSets?.flatMap(set => 
            set.memberInfos.map(p => ({ 
              email: p.email, 
              status: p.status,
              role: set.role,
              isWaiting: p.status === 'WAITING_FOR_OTHERS',
              requiresAction: ['WAITING_FOR_MY_SIGNATURE', 'WAITING_FOR_MY_APPROVAL', 
                'WAITING_FOR_MY_DELEGATION', 'WAITING_FOR_MY_ACCEPTANCE', 
                'WAITING_FOR_MY_FORM_FILLING'].includes(p.status),
              isComplete: ['SIGNED', 'APPROVED', 'ACCEPTED', 'FORM_FILLED', 
                'DELEGATED', 'COMPLETED'].includes(p.status)
            }))
          ) || []
        },
        documentInfo: {
          id: document._id,
          status: document.status,
          recipientCount: document.recipients.length,
          recipientStatuses: document.recipients.map(r => ({ email: r.email, status: r.status }))
        },
        alternativeMethod: !reminderSent ? 'Use Adobe Sign web interface to send reminders: https://echosign.adobe.com/' : null
      }
    ));
  } catch (error) {
    logger.error(`Error sending reminder: ${error.message}`);
    next(new ApiError(500, `Error sending reminder: ${error.message}`));
  }
};

/**
 * Get signing URL for embedding in iframe
 * @route GET /api/documents/:id/signing-url
 */
exports.getSigningUrl = async (req, res, next) => {
  try {
    const { id } = req.params;
    const { email } = req.query;

    // Find document
    const document = await Document.findById(id);
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }

    // Check if document has Adobe Sign agreement ID
    if (!document.adobeAgreementId) {
      return next(new ApiError(400, 'Document has not been sent for signature yet'));
    }

    // Get access token for Adobe Sign API
    const accessToken = await getAccessToken();
    
    try {
      // Get agreement info to check status and participants
      const agreementInfo = await getAgreementInfo(accessToken, document.adobeAgreementId);
      
      if (agreementInfo.status === 'CANCELLED' || agreementInfo.status === 'EXPIRED') {
        return next(new ApiError(400, `Agreement is ${agreementInfo.status.toLowerCase()}`));
      }
      
      // If specific email is provided, get URL for that participant
      if (email) {
        let participantFound = false;
        let signingUrl = null;
        
        // Check each participant set for the specified email
        if (agreementInfo.participantSets) {
          for (const participantSet of agreementInfo.participantSets) {
            for (const participant of participantSet.memberInfos) {
              if (participant.email.toLowerCase() === email.toLowerCase()) {
                participantFound = true;
                
                // If already signed, return message
                if (participant.status === 'SIGNED') {
                  return res.status(200).json(formatResponse(
                    200,
                    'Participant has already signed this document',
                    {
                      status: 'SIGNED',
                      email: participant.email
                    }
                  ));
                }
                
                // Get signing URL for this participant
                const response = await getSigningUrl(
                  accessToken, 
                  document.adobeAgreementId,
                  participant.participantId
                );
                
                signingUrl = response.signingUrlSetInfos[0].signingUrls[0].esignUrl;
                break;
              }
            }
            if (participantFound) break;
          }
        }
        
        if (!participantFound) {
          return next(new ApiError(404, `Participant with email ${email} not found in this agreement`));
        }
        
        if (!signingUrl) {
          return next(new ApiError(500, 'Failed to retrieve signing URL'));
        }
        
        // Create log entry
        const logEntry = new Log({
          level: 'info',
          message: `Retrieved signing URL for ${email}`,
          action: 'get_signing_url',
          documentId: document._id,
          userId: req.apiKey.userId || req.apiKey._id,
          details: {
            email,
            agreementId: document.adobeAgreementId
          }
        });
        
        await logEntry.save();
        
        return res.status(200).json(formatResponse(
          200,
          'Signing URL retrieved successfully',
          {
            signingUrl,
            recipient: {
              email,
              status: 'PENDING'
            },
            document: {
              id: document._id,
              name: document.originalName,
              agreementId: document.adobeAgreementId
            }
          }
        ));
      } else {
        // If no email specified, get first available signer URL
        let signingUrl = null;
        let recipientEmail = null;
        let recipientStatus = null;
        
        // Find first pending recipient
        if (agreementInfo.participantSets) {
          for (const participantSet of agreementInfo.participantSets) {
            for (const participant of participantSet.memberInfos) {
              if (participant.status !== 'SIGNED') {
                // Get signing URL for this participant
                const response = await getSigningUrl(
                  accessToken, 
                  document.adobeAgreementId,
                  participant.participantId
                );
                
                signingUrl = response.signingUrlSetInfos[0].signingUrls[0].esignUrl;
                recipientEmail = participant.email;
                recipientStatus = participant.status;
                break;
              }
            }
            if (signingUrl) break;
          }
        }
        
        if (!signingUrl) {
          return res.status(200).json(formatResponse(
            200,
            'No pending signers found. All participants have signed the document.',
            {
              status: 'COMPLETED',
              document: {
                id: document._id,
                name: document.originalName,
                agreementId: document.adobeAgreementId
              }
            }
          ));
        }
        
        // Create log entry
        const logEntry = new Log({
          level: 'info',
          message: `Retrieved signing URL for ${recipientEmail}`,
          action: 'get_signing_url',
          documentId: document._id,
          userId: req.apiKey.userId || req.apiKey._id,
          details: {
            email: recipientEmail,
            agreementId: document.adobeAgreementId
          }
        });
        
        await logEntry.save();
        
        return res.status(200).json(formatResponse(
          200,
          'Signing URL retrieved successfully',
          {
            signingUrl,
            recipient: {
              email: recipientEmail,
              status: recipientStatus
            },
            document: {
              id: document._id,
              name: document.originalName,
              agreementId: document.adobeAgreementId
            }
          }
        ));
      }
    } catch (error) {
      logger.error(`Error getting signing URL: ${error.message}`);
      return next(new ApiError(500, `Error getting signing URL: ${error.message}`));
    }
  } catch (error) {
    logger.error(`Error getting signing URL: ${error.message}`);
    next(new ApiError(500, `Error getting signing URL: ${error.message}`));
  }
};

/**
 * Get signing URLs for all recipients
 * @route GET /api/documents/:id/signing-urls
 */
exports.getAllSigningUrls = async (req, res, next) => {
  try {
    const { id } = req.params;

    // Find document
    const document = await Document.findById(id);
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }

    // Check if document has Adobe Sign agreement ID
    if (!document.adobeAgreementId) {
      return next(new ApiError(400, 'Document has not been sent for signature yet'));
    }

    // Get access token for Adobe Sign API
    const accessToken = await getAccessToken();
    
    try {
      // Get agreement info to check status and participants
      const agreementInfo = await getAgreementInfo(accessToken, document.adobeAgreementId);
      
      if (agreementInfo.status === 'CANCELLED' || agreementInfo.status === 'EXPIRED') {
        return next(new ApiError(400, `Agreement is ${agreementInfo.status.toLowerCase()}`));
      }
      
      const recipients = [];
      
      // Process each participant
      if (agreementInfo.participantSets) {
        for (const participantSet of agreementInfo.participantSets) {
          for (const participant of participantSet.memberInfos) {
            const recipientInfo = {
              email: participant.email,
              name: participant.name || participant.email.split('@')[0],
              status: participant.status,
              participantId: participant.participantId
            };
            
            // Skip if already signed
            if (participant.status === 'SIGNED') {
              recipientInfo.signingUrl = null;
              recipientInfo.message = 'Participant has already signed';
            } else {
              try {
                // Get signing URL for this participant
                const response = await getSigningUrl(
                  accessToken, 
                  document.adobeAgreementId,
                  participant.participantId
                );
                
                recipientInfo.signingUrl = response.signingUrlSetInfos[0].signingUrls[0].esignUrl;
              } catch (urlError) {
                logger.error(`Error getting signing URL for ${participant.email}: ${urlError.message}`);
                recipientInfo.signingUrl = null;
                recipientInfo.error = 'Failed to retrieve signing URL';
              }
            }
            
            recipients.push(recipientInfo);
          }
        }
      }
      
      // Create log entry
      const logEntry = new Log({
        level: 'info',
        message: `Retrieved signing URLs for document ${document._id}`,
        action: 'get_all_signing_urls',
        documentId: document._id,
        userId: req.apiKey.userId || req.apiKey._id,
        details: {
          agreementId: document.adobeAgreementId,
          recipientCount: recipients.length
        }
      });
      
      await logEntry.save();
      
      return res.status(200).json(formatResponse(
        200,
        'Signing URLs retrieved successfully',
        {
          recipients,
          document: {
            id: document._id,
            name: document.originalName,
            agreementId: document.adobeAgreementId,
            status: agreementInfo.status
          }
        }
      ));
    } catch (error) {
      logger.error(`Error getting signing URLs: ${error.message}`);
      return next(new ApiError(500, `Error getting signing URLs: ${error.message}`));
    }
  } catch (error) {
    logger.error(`Error getting signing URLs: ${error.message}`);
    next(new ApiError(500, `Error getting signing URLs: ${error.message}`));
  }
};

/**
 * Download document
 * @route GET /api/documents/:id/download
 */
exports.downloadDocument = async (req, res, next) => {
  try {
    const { id } = req.params;
    const { format } = req.query;

    // Find document
    const document = await Document.findById(id);
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }

    // Determine which file to download
    let filePath;
    let fileName;
    
    if (document.status === 'signed' && document.signedDocumentPath) {
      // Return the signed document if available
      filePath = document.signedDocumentPath;
      fileName = `${path.basename(document.originalName, path.extname(document.originalName))}_signed${path.extname(document.signedDocumentPath)}`;
    } else if (document.convertedFilePath) {
      // Return the converted PDF
      filePath = document.convertedFilePath;
      fileName = `${path.basename(document.originalName, path.extname(document.originalName))}_converted.pdf`;
    } else if (document.processedFilePath) {
      // Return the processed file
      filePath = document.processedFilePath;
      fileName = `${path.basename(document.originalName, path.extname(document.originalName))}_processed${path.extname(document.processedFilePath)}`;
    } else {
      // Return the original file
      filePath = document.filePath;
      fileName = document.originalName;
    }

    // Check if file exists
    if (!fs.existsSync(filePath)) {
      return next(new ApiError(404, 'File not found on server'));
    }

    // Create log entry
    const logEntry = new Log({
      level: 'info',
      message: `Document ${document._id} downloaded`,
      action: 'download_document',
      documentId: document._id,
      userId: req.apiKey.userId || req.apiKey._id,
      details: {
        fileName,
        documentStatus: document.status
      }
    });
    
    await logEntry.save();

    // If document is signed but we don't have a local copy, try to download from Adobe Sign
    if (document.status === 'signed' && document.adobeAgreementId && !document.signedDocumentPath) {
      try {
        // Get access token for Adobe Sign API
        const accessToken = await getAccessToken();
        
        // Download the document
        const tempFilePath = path.join(
          path.dirname(document.filePath), 
          `${path.basename(document.filePath, path.extname(document.filePath))}_signed.pdf`
        );
        
        // Download signed agreement from Adobe Sign
        const fileBuffer = await downloadSignedDocument(accessToken, document.adobeAgreementId);
        
        // Save the file
        fs.writeFileSync(tempFilePath, fileBuffer);
        
        // Update document record
        document.signedDocumentPath = tempFilePath;
        await document.save();
        
        // Update the file path to download
        filePath = tempFilePath;
        fileName = `${path.basename(document.originalName, path.extname(document.originalName))}_signed.pdf`;
        
        logger.info(`Downloaded signed document from Adobe Sign for ${document._id}`);
      } catch (error) {
        logger.error(`Error downloading signed document from Adobe Sign: ${error.message}`);
        // Continue with what we have locally
      }
    }

    // Set headers for download
    res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(fileName)}"`);
    res.setHeader('Content-Type', mime.lookup(filePath) || 'application/octet-stream');
    
    // Stream the file
    const fileStream = fs.createReadStream(filePath);
    fileStream.pipe(res);
  } catch (error) {
    logger.error(`Error downloading document: ${error.message}`);
    next(new ApiError(500, `Error downloading document: ${error.message}`));
  }
};

/**
 * Check and update the signature status of a document
 * @route POST /api/documents/:id/update-status
 */
exports.updateSignatureStatus = async (req, res, next) => {
  try {
    const documentId = req.params.id;
    
    // Find document
    const document = await Document.findById(documentId);
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }
    
    // Check if document has an Adobe agreement ID
    if (!document.adobeAgreementId) {
      return next(new ApiError(400, 'Document has not been sent for signature yet'));
    }
    
    // Get access token
    const accessToken = await getAccessToken();
    
    // Get agreement info
    const agreementInfo = await getAgreementInfo(accessToken, document.adobeAgreementId);
    
    logger.info(`Retrieved agreement info for ${documentId}, status: ${agreementInfo.status}`);
    
    // Update document status based on agreement status
    switch (agreementInfo.status) {
      case 'SIGNED':
        document.status = 'completed';
        break;
      case 'CANCELLED':
        document.status = 'cancelled';
        break;
      case 'EXPIRED':
        document.status = 'expired';
        break;
      case 'OUT_FOR_SIGNATURE':
      case 'OUT_FOR_APPROVAL':
        // Check if partially signed
        if (document.recipients.some(r => r.status === 'signed')) {
          document.status = 'partially_signed';
        } else {
          document.status = 'sent_for_signature';
        }
        break;
      default:
        document.status = 'sent_for_signature';
    }
    
    // Update recipient status
    if (agreementInfo.participantSets && agreementInfo.participantSets.length > 0) {
      for (const participantSet of agreementInfo.participantSets) {
        for (const participant of participantSet.memberInfos) {
          // Find matching recipient by email
          const recipientIndex = document.recipients.findIndex(
            r => r.email.toLowerCase() === participant.email.toLowerCase()
          );
          
          if (recipientIndex !== -1) {
            // Update recipient status
            const recipient = document.recipients[recipientIndex];
            
            switch (participant.status) {
              case 'SIGNED':
                recipient.status = 'signed';
                // Only update signedAt if not already set
                if (!recipient.signedAt) {
                  recipient.signedAt = new Date();
                }
                break;
              case 'APPROVED':
                recipient.status = 'signed';
                // Only update signedAt if not already set
                if (!recipient.signedAt) {
                  recipient.signedAt = new Date();
                }
                break;
              case 'WAITING_FOR_MY_SIGNATURE':
              case 'WAITING_FOR_MY_APPROVAL':
                recipient.status = 'pending';
                break;
              case 'WAITING_FOR_OTHERS':
                recipient.status = 'waiting';
                break;
              case 'DECLINED':
                recipient.status = 'declined';
                break;
              case 'EXPIRED':
                recipient.status = 'expired';
                break;
              case 'NOT_YET_VISIBLE':
                recipient.status = 'pending';
                break;
              default:
                // Keep existing status if unknown
                break;
            }
            
            logger.info(`Updated recipient ${recipient.email} status to ${recipient.status}`);
          }
        }
      }
    }
    
    // Save updated document
    await document.save();
    
    // Return updated document
    return res.status(200).json(formatResponse('Document signature status updated successfully', {
      document: documentUtils.sanitizeDocument(document)
    }));
  } catch (error) {
    logger.error(`Error updating signature status: ${error.message}`);
    return next(new ApiError(500, `Failed to update signature status: ${error.message}`));
  }
};

/**
 * Recover document from socket hang up error
 * @route POST /api/documents/:id/recover
 */
exports.recoverDocument = async (req, res, next) => {
  try {
    const { id } = req.params;
    logger.info(`Starting document recovery for ID: ${id}`);
    
    // Call the recovery utility
    const recoveryResult = await recoverDocumentUtil(id);
    
    if (recoveryResult.success) {
      // Log the recovery
      await Log.create({
        action: 'document_recovery',
        status: 'success',
        details: {
          documentId: id,
          method: recoveryResult.verifiedRecovery ? 'verified' : 'aggressive',
          timestamp: new Date()
        }
      });
      
      return res.status(200).json({
        success: true,
        status: 200,
        message: recoveryResult.message,
        data: {
          document: recoveryResult.document,
          agreementId: recoveryResult.adobeAgreementId || 'unknown',
          recoveryApplied: !!recoveryResult.recoveryApplied,
          verifiedRecovery: !!recoveryResult.verifiedRecovery
        }
      });
    } else {
      // Log the failed recovery attempt
      await Log.create({
        action: 'document_recovery',
        status: 'failure',
        details: {
          documentId: id,
          error: recoveryResult.message,
          timestamp: new Date()
        }
      });
      
      return res.status(400).json({
        success: false,
        status: 400,
        message: recoveryResult.message,
        data: {
          document: recoveryResult.document || null
        }
      });
    }
  } catch (error) {
    logger.error(`Error in document recovery: ${error.message}`);
    return next(new ApiError(500, `Document recovery failed: ${error.message}`));
  }
};
    // Save updated document
    await document.save();
    
    // Return updated document
    return res.status(200).json(formatResponse('Document signature status updated successfully', {
      document: documentUtils.sanitizeDocument(document)
    }));
  } catch (error) {
    logger.error(`Error updating signature status: ${error.message}`);
    return next(new ApiError(500, `Failed to update signature status: ${error.message}`));
  }
};