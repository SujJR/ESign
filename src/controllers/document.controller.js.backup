const Document = require('../models/document.model');
const Log = require('../models/log.model');
const { ApiError, formatResponse } = require('../utils/apiUtils');
const logger = require('../utils/logger');
const documentUtils = require('../utils/documentUtils');
const documentProcessor = require('../utils/documentProcessor');
const rateLimitProtection = require('../utils/rateLimitProtection');

// Import enhanced Adobe Sign client
const { 
  getAccessToken, 
  uploadTransientDocument, 
  getAgreementInfo, 
  getComprehensiveAgreementInfo,
  getActualSigningStatus,
  sendReminder, 
  createWebhook, 
  getSigningUrl, 
  downloadSignedDocument 
} = require('../config/adobeSign');

const fs = require('fs');
const path = require('path');
const mime = require('mime');
const { createAgreementWithBestApproach, verifyAdobeSignTextTags } = require('../utils/adobeSignFormFields');
const adobeSignTagHandler = require('../utils/adobeSignTagHandler');
const emailService = require('../services/emailService');
const urlUtils = require('../utils/urlUtils');

/**
 * Helper function to extract recipients from template data
 * @param {Object} templateData - Template data containing recipient information
 * @returns {Array} - Array of recipient objects
 */
const extractRecipientsFromTemplateData = (templateData) => {
  const recipients = [];
  const emailSet = new Set(); // Track emails to prevent duplicates
  
  // PRIORITY 1: Check for explicit recipients array first
  if (templateData.recipients && Array.isArray(templateData.recipients) && templateData.recipients.length > 0) {
    logger.info('Using explicit recipients array from template data');
    templateData.recipients.forEach((recipient, index) => {
      if (recipient.name && recipient.email && !emailSet.has(recipient.email.toLowerCase())) {
        emailSet.add(recipient.email.toLowerCase());
        recipients.push({
          name: recipient.name,
          email: recipient.email,
          title: recipient.title || '',
          signatureField: recipient.signatureField || `signature_recipient_${index + 1}`
        });
      }
    });
  } else {
    // PRIORITY 2: Fall back to individual field patterns only if no recipients array
    logger.info('No recipients array found, extracting from individual fields');
    const recipientFields = [
      { nameField: 'signerName', emailField: 'signerEmail', titleField: 'signerTitle' },
      { nameField: 'clientName', emailField: 'clientEmail', titleField: 'clientTitle' },
      { nameField: 'witnessName', emailField: 'witnessEmail', titleField: 'witnessTitle' }
      // Note: Removed projectManager and approverName as they are typically not signers
    ];
    
    // Extract recipients based on field patterns
    recipientFields.forEach((fieldSet, index) => {
      const name = templateData[fieldSet.nameField];
      const email = templateData[fieldSet.emailField];
      const title = templateData[fieldSet.titleField];
      
      if (name && email && !emailSet.has(email.toLowerCase())) {
        emailSet.add(email.toLowerCase());
        recipients.push({
          name: name,
          email: email,
          title: title || '',
          signatureField: `signature_${fieldSet.nameField.toLowerCase().replace('name', '')}`
        });
      }
    });
  }
  
  logger.info(`Extracted ${recipients.length} unique recipients for signature from template data`);
  return recipients;
};

/**
 * Upload a document for e-signature with optional JSON data for template processing
 * @route POST /api/documents/upload
 */
exports.uploadDocument = async (req, res, next) => {
  try {
    if (!req.file) {
      return next(new ApiError(400, 'No document uploaded'));
    }
    
    // Extract file information
    const { filename, originalname, mimetype, size, path: filePath } = req.file;
    
    // Initialize document data
    let documentData = {
      filename,
      originalName: originalname,
      fileSize: size,
      filePath,
      mimeType: mimetype,
      status: 'uploaded'
    };
    
    // Check if it's a PDF or needs processing
    const fileExtension = path.extname(originalname).toLowerCase();
    let finalPdfPath = filePath;
    let pageCount = 0;
    
    if (fileExtension === '.pdf') {
      // Analyze PDF to get page count
      const pdfInfo = await documentUtils.analyzePdf(filePath);
      pageCount = pdfInfo.pageCount;
    } else if (['.docx', '.doc'].includes(fileExtension)) {
      // Process DOCX/DOC file
      try {
        // Analysis and processing logic for DOCX/DOC
        const analysis = await documentProcessor.analyzeDocumentForSignatureFields(filePath);
        
        documentData.templateVariables = analysis.templateVariables;
        documentData.documentAnalysis = analysis;
        
        // Check for Adobe Sign tags before attempting standard processing
        const hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(filePath);
        
        if (hasAdobeSignTags) {
          logger.info('Detected Adobe Sign tags in document, using direct bypass processing');
          documentData.containsAdobeSignTags = true;
          
          if (Object.keys(templateData).length > 0) {
            // Use the direct bypass approach for maximum tag preservation
            try {
              logger.info('Using direct bypass approach for Adobe Sign tags');
              processedFilePath = await adobeSignBypass.bypassTemplateProcessing(filePath, templateData);
              documentData.processedFilePath = processedFilePath;
              finalPdfPath = await adobeSignBypass.convertToPdf(processedFilePath);
            } catch (bypassError) {
              logger.warn(`Direct bypass failed: ${bypassError.message}, trying specialized handler...`);
              // Fall back to the specialized handler
              processedFilePath = await documentProcessor.processDocumentWithAdobeSignTags(filePath, templateData);
              documentData.processedFilePath = processedFilePath;
              finalPdfPath = await documentProcessor.convertDocxToPdf(processedFilePath);
            }
          } else {
            // No template data, just convert to PDF
            finalPdfPath = await documentProcessor.convertDocxToPdf(filePath);
          }
        } else {
          // Standard template processing path (no Adobe Sign tags)
          if (Object.keys(templateData).length > 0) {
            processedFilePath = await documentProcessor.processDocumentTemplate(filePath, templateData);
            documentData.processedFilePath = processedFilePath;
            finalPdfPath = await documentProcessor.convertDocxToPdf(processedFilePath);
          } else {
            finalPdfPath = await documentProcessor.convertDocxToPdf(filePath);
          }
        }
        
        documentData.pdfFilePath = finalPdfPath;
        documentData.autoDetectedSignatureFields = (analysis.signatureFields || []).map(field => {
          if (typeof field === 'object' && field.name) {
            // Field is an object with positioning data - extract the proper structure for Adobe Sign
            return {
              name: field.name,
              type: field.type.toLowerCase(),
              required: true,
              x: field.x,
              y: field.y,
              width: field.width,
              height: field.height,
              page: field.page,
              detected: true
            };
          } else {
            // Fallback for string-based fields
            return {
              name: field,
              type: 'signature',
              required: true
            };
          }
        });
        
        // Analyze the converted PDF
        const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
        pageCount = pdfInfo.pageCount;
        
        // Check if the document has Adobe Sign text tags and verify their format
        if (documentData.autoDetectedSignatureFields && documentData.autoDetectedSignatureFields.length > 0) {
          const verificationResult = verifyAdobeSignTextTags(documentData.autoDetectedSignatureFields);
          if (verificationResult.hasTags) {
            logger.info('Adobe Sign text tags detected in document');
            
            if (!verificationResult.correctFormat) {
              logger.warn('Issues found with Adobe Sign text tags:');
              verificationResult.issuesFound.forEach(issue => logger.warn(`- ${issue}`));
              logger.warn('Recommendations:');
              verificationResult.recommendations.forEach(rec => logger.warn(`- ${rec}`));
              
              // If there are issues, add a message to the response
              documentData.textTagIssues = verificationResult.issuesFound;
              documentData.textTagRecommendations = verificationResult.recommendations;
            } else {
              logger.info('Adobe Sign text tags verification passed - signatures should appear at tag positions');
            }
            
            documentData.hasAdobeSignTags = true;
          }
        }
        
        logger.info(`Document processed successfully. Found ${analysis.templateVariables.length} template variables`);
      } catch (processingError) {
        logger.error(`Error processing document: ${processingError.message}`);
        
        // Check if this might be an Adobe Sign tag related error
        // The specific error you're seeing is "Template Error: Multi error"
        if (processingError.message.includes('Multi error') || 
            processingError.message.includes('Template Error') ||
            processingError.message.includes('unopened tag') ||
            processingError.message.includes('unclosed tag') ||
            processingError.message.includes('Error: {')) {
          
          try {
            logger.info('Detected potential Adobe Sign tag related error, checking document');
            // Check for Adobe Sign tags in the document
            const hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(filePath);
            
            if (hasAdobeSignTags) {
              logger.info('Adobe Sign tags detected, using specialized processing instead');
              
              // Use the specialized handler for Adobe Sign tags
              processedFilePath = await documentProcessor.processDocumentWithAdobeSignTags(filePath, templateData);
              documentData.processedFilePath = processedFilePath;
              documentData.hasAdobeSignTags = true;
              
              // Convert processed document to PDF
              finalPdfPath = await documentProcessor.convertDocxToPdf(processedFilePath);
              documentData.pdfFilePath = finalPdfPath;
              
              // Analyze the converted PDF
              const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
              pageCount = pdfInfo.pageCount;
              
              logger.info('Successfully recovered from template error using Adobe Sign handler');
            } else {
              // If not Adobe Sign tags, re-throw original error
              throw processingError;
            }
          } catch (recoveryError) {
            if (recoveryError !== processingError) {
              logger.error(`Recovery attempt failed: ${recoveryError.message}`);
            }
            return next(new ApiError(400, `Error processing document template: ${processingError.message}`));
          }
        } else {
          return next(new ApiError(400, `Error processing document: ${processingError.message}`));
        }
      }
    } else {
      return next(new ApiError(400, 'Unsupported file format. Only PDF, DOCX, and DOC files are allowed'));
    }
    
    documentData.pageCount = pageCount;
    
    // Create document record in database
    const document = await Document.create(documentData);
    
    // Log document upload
    await Log.create({
      level: 'info',
      message: `Document uploaded: ${originalname}`,
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,
      requestMethod: req.method,
      metadata: {
        fileSize: size,
        mimeType: mimetype,
        templateVariables: documentData.templateVariables || [],
        autoDetectedFields: documentData.autoDetectedSignatureFields?.length || 0
      }
    });
    
    logger.info(`Document uploaded: ${originalname}`);
    
    res.status(201).json(formatResponse(
      201,
      'Document uploaded successfully',
      { 
        document,
        templateVariables: documentData.templateVariables || [],
        autoDetectedSignatureFields: documentData.autoDetectedSignatureFields || []
      }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Upload a document with JSON data for template processing
 * @route POST /api/documents/upload-with-data
 */
exports.uploadDocumentWithData = async (req, res, next) => {
  try {
    if (!req.files || (!req.files.document && !req.files.documents)) {
      return next(new ApiError(400, 'No document uploaded'));
    }
    
    // Support both 'document' and 'documents' field names
    const documentFile = req.files.document ? req.files.document[0] : req.files.documents[0];
    const dataFile = req.files.data ? req.files.data[0] : null;
    
    // Extract file information
    const { filename, originalname, mimetype, size, path: filePath } = documentFile;
    
    // Parse JSON data if provided
    let templateData = {};
    if (dataFile) {
      try {
        const jsonContent = fs.readFileSync(dataFile.path, 'utf8');
        templateData = JSON.parse(jsonContent);
        
        // Clean up the temporary JSON file
        fs.unlinkSync(dataFile.path);
        
        logger.info(`JSON data file processed with ${Object.keys(templateData).length} variables`);
      } catch (jsonError) {
        logger.error(`Error parsing JSON data: ${jsonError.message}`);
        return next(new ApiError(400, 'Invalid JSON data file'));
      }
    }
    
    // Parse JSON data from request body if provided instead of file
    if (!dataFile && req.body.templateData) {
      try {
        templateData = typeof req.body.templateData === 'string' 
          ? JSON.parse(req.body.templateData) 
          : req.body.templateData;
      } catch (jsonError) {
        logger.error(`Error parsing JSON data from body: ${jsonError.message}`);
        return next(new ApiError(400, 'Invalid JSON data in request body'));
      }
    }
    
    // Initialize document data
    let documentData = {
      filename,
      originalName: originalname,
      fileSize: size,
      filePath,
      mimeType: mimetype,
      status: 'uploaded',
      templateData
    };
    
    // Check if it's a PDF or needs processing
    const fileExtension = path.extname(originalname).toLowerCase();
    let finalPdfPath = filePath;
    let pageCount = 0;
    let processedFilePath = null;
    
    if (fileExtension === '.pdf') {
      // Analyze PDF to get page count
      const pdfInfo = await documentUtils.analyzePdf(filePath);
      pageCount = pdfInfo.pageCount;
      
      // Even PDFs can have template variables in text layers
      try {
        const analysis = await documentProcessor.analyzeDocumentForSignatureFields(filePath);
        documentData.templateVariables = analysis.templateVariables;
        documentData.documentAnalysis = analysis;
        documentData.autoDetectedSignatureFields = (analysis.signatureFields || []).map(field => {
          if (typeof field === 'object' && field.name) {
            return {
              name: field.name,
              type: field.type.toLowerCase(),
              required: true,
              x: field.x,
              y: field.y,
              width: field.width,
              height: field.height,
              page: field.page,
              detected: true
            };
          } else {
            return {
              name: field,
              type: 'signature',
              required: true
            };
          }
        });
      } catch (analysisError) {
        logger.warn(`Could not analyze PDF for template variables: ${analysisError.message}`);
      }
    } else if (['.docx', '.doc'].includes(fileExtension)) {
      // Process DOCX/DOC file with template data
      try {
        // First analyze the document
        const analysis = await documentProcessor.analyzeDocumentForSignatureFields(filePath);
        
        // Process template with data if provided
        if (Object.keys(templateData).length > 0) {
          try {
            // Use our specialized Adobe Sign tag handler to process the document
            const processResult = await adobeSignTagHandler.processDocumentWithTags(filePath, templateData);
            
            // Update document data with paths and processing info
            processedFilePath = processResult.processedFilePath;
            finalPdfPath = processResult.pdfFilePath;
            documentData.processedFilePath = processedFilePath;
            documentData.pdfFilePath = finalPdfPath;
            documentData.hasAdobeSignTags = processResult.hasAdobeSignTags;
          } catch (processingError) {
            logger.error(`Error processing document with tags: ${processingError.message}`);
            return next(new ApiError(400, `Error processing document template: ${processingError.message}`));
          }
        } else {
          // No template data, just convert the original document to PDF
          finalPdfPath = await documentProcessor.convertDocxToPdf(filePath);
          documentData.pdfFilePath = finalPdfPath;
        }
        
        documentData.templateVariables = analysis.templateVariables;
        documentData.documentAnalysis = analysis;
        
        // Analyze the converted PDF
        const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
        pageCount = pdfInfo.pageCount;
        
        // Check if the document has Adobe Sign text tags and verify their format
        if (documentData.autoDetectedSignatureFields && documentData.autoDetectedSignatureFields.length > 0) {
          const verificationResult = verifyAdobeSignTextTags(documentData.autoDetectedSignatureFields);
          if (verificationResult.hasTags) {
            logger.info('Adobe Sign text tags detected in document');
            
            if (!verificationResult.correctFormat) {
              logger.warn('Issues found with Adobe Sign text tags:');
              verificationResult.issuesFound.forEach(issue => logger.warn(`- ${issue}`));
              logger.warn('Recommendations:');
              verificationResult.recommendations.forEach(rec => logger.warn(`- ${rec}`));
              
              // If there are issues, add a message to the response
              documentData.textTagIssues = verificationResult.issuesFound;
              documentData.textTagRecommendations = verificationResult.recommendations;
            } else {
              logger.info('Adobe Sign text tags verification passed - signatures should appear at tag positions');
            }
            
            documentData.hasAdobeSignTags = true;
          }
        }
        
        logger.info(`Document processed successfully. Found ${analysis.templateVariables.length} template variables`);
      } catch (processingError) {
        logger.error(`Error processing document: ${processingError.message}`);
        
        // Check if this might be an Adobe Sign tag related error
        // The specific error you're seeing is "Template Error: Multi error"
        if (processingError.message.includes('Multi error') || 
            processingError.message.includes('Template Error') ||
            processingError.message.includes('unopened tag') ||
            processingError.message.includes('unclosed tag') ||
            processingError.message.includes('Error: {')) {
          
          try {
            logger.info('Detected potential Adobe Sign tag related error, checking document');
            // Check for Adobe Sign tags in the document
            const hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(filePath);
            
            if (hasAdobeSignTags) {
              logger.info('Adobe Sign tags detected, using specialized processing instead');
              
              // Use the specialized handler for Adobe Sign tags
              processedFilePath = await documentProcessor.processDocumentWithAdobeSignTags(filePath, templateData);
              documentData.processedFilePath = processedFilePath;
              documentData.hasAdobeSignTags = true;
              
              // Convert processed document to PDF
              finalPdfPath = await documentProcessor.convertDocxToPdf(processedFilePath);
              documentData.pdfFilePath = finalPdfPath;
              
              // Analyze the converted PDF
              const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
              pageCount = pdfInfo.pageCount;
              
              logger.info('Successfully recovered from template error using Adobe Sign handler');
            } else {
              // If not Adobe Sign tags, re-throw original error
              throw processingError;
            }
          } catch (recoveryError) {
            if (recoveryError !== processingError) {
              logger.error(`Recovery attempt failed: ${recoveryError.message}`);
            }
            return next(new ApiError(400, `Error processing document template: ${processingError.message}`));
          }
        } else {
          return next(new ApiError(400, `Error processing document: ${processingError.message}`));
        }
      }
    } else {
      return next(new ApiError(400, 'Unsupported file format. Only PDF, DOCX, and DOC files are allowed'));
    }
    
    documentData.pageCount = pageCount;
    
    // Create document record in database
    const document = await Document.create(documentData);
    
    // Log document upload
    await Log.create({
      level: 'info',
      message: `Document uploaded with template data: ${originalname}`,
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,
      requestMethod: req.method,
      metadata: {
        fileSize: size,
        mimeType: mimetype,
        templateVariables: documentData.templateVariables || [],
        templateDataKeys: Object.keys(templateData),dSignatureFields?.length || 0
        autoDetectedFields: documentData.autoDetectedSignatureFields?.length || 0,
        hasProcessedFile: !!processedFilePath,
        containsAdobeSignTags: true
      }ger.info(`Document uploaded: ${originalname}`);
    });
    res.status(201).json(formatResponse(
    logger.info(`Document uploaded with template data: ${originalname}`);
      'Document uploaded successfully',
    res.status(201).json(formatResponse(
      201,cument,
      'Document uploaded and processed successfully (with Adobe Sign tags)',
      { autoDetectedSignatureFields: documentData.autoDetectedSignatureFields || []
        document,
        templateVariables: documentData.templateVariables || [],
        templateDataApplied: Object.keys(templateData),
        autoDetectedSignatureFields: documentData.autoDetectedSignatureFields || [],
        processedWithTemplateData: Object.keys(templateData).length > 0,
        containsAdobeSignTags: true
      }
    ));
    pload a document with JSON data for template processing
    return; // End function execution here - we've sent the response
  } catch (error) {
    next(error);cumentWithData = async (req, res, next) => {
  }ry {
};  if (!req.files || (!req.files.document && !req.files.documents)) {
      return next(new ApiError(400, 'No document uploaded'));
/** }
 * Combined endpoint: Upload document with data, prepare, and send for signature
 * @route POST /api/documents/upload-and-send' field names
 */ const documentFile = req.files.document ? req.files.document[0] : req.files.documents[0];
exports.uploadPrepareAndSend = async (req, res, next) => {ull;
  try {
    // Step 1: Upload and process document (reuse uploadDocumentWithData logic)
    if (!req.files || (!req.files.document && !req.files.documents)) {const { filename, originalname, mimetype, size, path: filePath } = documentFile;
      return next(new ApiError(400, 'No document uploaded'));
    }
    et templateData = {};
    // Support both 'document' and 'documents' field namesif (dataFile) {
    const documentFile = req.files.document ? req.files.document[0] : req.files.documents[0];
    const dataFile = req.files.data ? req.files.data[0] : null;tent = fs.readFileSync(dataFile.path, 'utf8');
    emplateData = JSON.parse(jsonContent);
    // Extract file information
    const { filename, originalname, mimetype, size, path: filePath } = documentFile;rary JSON file
    
    // Parse JSON data if provided  
    let templateData = {};templateData).length} variables`);
    if (dataFile) {
      try {essage}`);
        const jsonContent = fs.readFileSync(dataFile.path, 'utf8');ile'));
        templateData = JSON.parse(jsonContent);
        
        // Clean up the temporary JSON file
        fs.unlinkSync(dataFile.path);
        
        logger.info(`JSON data file processed with ${Object.keys(templateData).length} variables`);
      } catch (jsonError) {
        logger.error(`Error parsing JSON data: ${jsonError.message}`);
        return next(new ApiError(400, 'Invalid JSON data file'));
      }
    }
    
    // Parse JSON data from request body if provided instead of file
    if (!dataFile && req.body.templateData) {
      try {
        templateData = typeof req.body.templateData === 'string' / Initialize document data
          ? JSON.parse(req.body.templateData) let documentData = {
          : req.body.templateData;
      } catch (jsonError) {inalname,
        logger.error(`Error parsing JSON data from body: ${jsonError.message}`);
        return next(new ApiError(400, 'Invalid JSON data in request body'));
      }
    }
    
    // Initialize document data
    let documentData = {
      filename,// Check if it's a PDF or needs processing
      originalName: originalname,riginalname).toLowerCase();
      fileSize: size,ePath;
      filePath,
      mimeType: mimetype,
      status: 'uploaded',
      templateData
    };
     documentUtils.analyzePdf(filePath);
    // Check if it's a PDF or needs processing
    const fileExtension = path.extname(originalname).toLowerCase();
    let finalPdfPath = filePath;/ Even PDFs can have template variables in text layers
    let pageCount = 0;
    let processedFilePath = null;rSignatureFields(filePath);
    umentData.templateVariables = analysis.templateVariables;
    if (fileExtension === '.pdf') {
      // Analyze PDF to get page countFields = (analysis.signatureFields || []).map(field => {
      const pdfInfo = await documentUtils.analyzePdf(filePath); 'object' && field.name) {
      pageCount = pdfInfo.pageCount;
    } else if (['.docx', '.doc'].includes(fileExtension)) {ld.name,
      // Process DOCX/DOC file
      try {
        // Analysis and processing logic for DOCX/DOC       x: field.x,
        const analysis = await documentProcessor.analyzeDocumentForSignatureFields(filePath);         y: field.y,
                  width: field.width,
        documentData.templateVariables = analysis.templateVariables;
        documentData.documentAnalysis = analysis;
        
        // Check for Adobe Sign tags before attempting standard processing
        const hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(filePath);      } else {
        
        if (hasAdobeSignTags) {
          logger.info('Detected Adobe Sign tags in document, using direct bypass processing');          type: 'signature',
          documentData.containsAdobeSignTags = true;
             };
          if (Object.keys(templateData).length > 0) {
            // Use the direct bypass approach for maximum tag preservation
            try {} catch (analysisError) {
              logger.info('Using direct bypass approach for Adobe Sign tags');alyze PDF for template variables: ${analysisError.message}`);
              processedFilePath = await adobeSignBypass.bypassTemplateProcessing(filePath, templateData);
              documentData.processedFilePath = processedFilePath;
              finalPdfPath = await adobeSignBypass.convertToPdf(processedFilePath);/ Process DOCX/DOC file with template data
            } catch (bypassError) {try {
              logger.warn(`Direct bypass failed: ${bypassError.message}, trying specialized handler...`);
              // Fall back to the specialized handlerPath);
              processedFilePath = await documentProcessor.processDocumentWithAdobeSignTags(filePath, templateData);
              documentData.processedFilePath = processedFilePath;  // Process template with data if provided
              finalPdfPath = await documentProcessor.convertDocxToPdf(processedFilePath);
            }
          } else {
            // No template data, just convert to PDF    const processResult = await adobeSignTagHandler.processDocumentWithTags(filePath, templateData);
            finalPdfPath = await documentProcessor.convertDocxToPdf(filePath);
          }
        } else {
          // Standard template processing path (no Adobe Sign tags);
          if (Object.keys(templateData).length > 0) {Path = processedFilePath;
            processedFilePath = await documentProcessor.processDocumentTemplate(filePath, templateData);
            documentData.processedFilePath = processedFilePath;.hasAdobeSignTags;
            finalPdfPath = await documentProcessor.convertDocxToPdf(processedFilePath);
          } else { document with tags: ${processingError.message}`);
            finalPdfPath = await documentProcessor.convertDocxToPdf(filePath);  return next(new ApiError(400, `Error processing document template: ${processingError.message}`));
          }
        } else {
           // No template data, just convert the original document to PDF
        documentData.pdfFilePath = finalPdfPath;await documentProcessor.convertDocxToPdf(filePath);
        documentData.autoDetectedSignatureFields = (analysis.signatureFields || []).map(field => {
          if (typeof field === 'object' && field.name) {
            // Field is an object with positioning data - extract the proper structure for Adobe Sign   
            return {    documentData.templateVariables = analysis.templateVariables;
              name: field.name,nalysis;
              type: field.type.toLowerCase(),
              required: true,    // Analyze the converted PDF
              x: field.x,alyzePdf(finalPdfPath);
              y: field.y,
              width: field.width,
              height: field.height,Check if the document has Adobe Sign text tags and verify their format
              page: field.page,tectedSignatureFields.length > 0) {
              detected: trueAdobeSignTextTags(documentData.autoDetectedSignatureFields);
            };
          } else {('Adobe Sign text tags detected in document');
            // Fallback for string-based fields
            return {
              name: field,arn('Issues found with Adobe Sign text tags:');
              type: 'signature',suesFound.forEach(issue => logger.warn(`- ${issue}`));
              required: true
            };       verificationResult.recommendations.forEach(rec => logger.warn(`- ${rec}`));
          }
        });
        cationResult.issuesFound;
        // Analyze the converted PDF documentData.textTagRecommendations = verificationResult.recommendations;
        const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
        pageCount = pdfInfo.pageCount; Sign text tags verification passed - signatures should appear at tag positions');
          }
        // Check if the document has Adobe Sign text tags and verify their format
        if (documentData.autoDetectedSignatureFields && documentData.autoDetectedSignatureFields.length > 0) {
          const verificationResult = verifyAdobeSignTextTags(documentData.autoDetectedSignatureFields);
          if (verificationResult.hasTags) {
            logger.info('Adobe Sign text tags detected in document');
            lysis.templateVariables.length} template variables`);
            if (!verificationResult.correctFormat) {
              logger.warn('Issues found with Adobe Sign text tags:');r.message}`);
              verificationResult.issuesFound.forEach(issue => logger.warn(`- ${issue}`));
              logger.warn('Recommendations:');ck if this might be an Adobe Sign tag related error
              verificationResult.recommendations.forEach(rec => logger.warn(`- ${rec}`));
              ocessingError.message.includes('Multi error') || 
              // If there are issues, add a message to the responser') ||
              documentData.textTagIssues = verificationResult.issuesFound;
              documentData.textTagRecommendations = verificationResult.recommendations;ocessingError.message.includes('unclosed tag') ||
            } else {ncludes('Error: {')) {
              logger.info('Adobe Sign text tags verification passed - signatures should appear at tag positions');
            }
            o('Detected potential Adobe Sign tag related error, checking document');
            documentData.hasAdobeSignTags = true;
          }
        }
        (hasAdobeSignTags) {
        logger.info(`Document processed successfully. Found ${analysis.templateVariables.length} template variables`);.info('Adobe Sign tags detected, using specialized processing instead');
      } catch (processingError) {
        logger.error(`Error processing document: ${processingError.message}`);ed handler for Adobe Sign tags
         processedFilePath = await documentProcessor.processDocumentWithAdobeSignTags(filePath, templateData);
        // Check if this might be an Adobe Sign tag related error   documentData.processedFilePath = processedFilePath;
        // The specific error you're seeing is "Template Error: Multi error"    documentData.hasAdobeSignTags = true;
        if (processingError.message.includes('Multi error') || 
            processingError.message.includes('Template Error') ||    // Convert processed document to PDF
            processingError.message.includes('unopened tag') ||= await documentProcessor.convertDocxToPdf(processedFilePath);
            processingError.message.includes('unclosed tag') ||
            processingError.message.includes('Error: {')) {
          
          try {    const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
            logger.info('Detected potential Adobe Sign tag related error, checking document');fo.pageCount;
            // Check for Adobe Sign tags in the document
            const hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(filePath);g Adobe Sign handler');
            
            if (hasAdobeSignTags) { error
              logger.info('Adobe Sign tags detected, using specialized processing instead');  throw processingError;
              
              // Use the specialized handler for Adobe Sign tags
              processedFilePath = await documentProcessor.processDocumentWithAdobeSignTags(filePath, templateData);
              documentData.processedFilePath = processedFilePath;veryError.message}`);
              documentData.hasAdobeSignTags = true;
              0, `Error processing document template: ${processingError.message}`));
              // Convert processed document to PDF
              finalPdfPath = await documentProcessor.convertDocxToPdf(processedFilePath);
              documentData.pdfFilePath = finalPdfPath;turn next(new ApiError(400, `Error processing document: ${processingError.message}`));
              
              // Analyze the converted PDF
              const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
              pageCount = pdfInfo.pageCount;, DOCX, and DOC files are allowed'));
              
              logger.info('Successfully recovered from template error using Adobe Sign handler');
            } else {Count;
              // If not Adobe Sign tags, re-throw original error
              throw processingError;te document record in database
            }document = await Document.create(documentData);
          } catch (recoveryError) {
            if (recoveryError !== processingError) {
              logger.error(`Recovery attempt failed: ${recoveryError.message}`);
            }
            return next(new ApiError(400, `Error processing document template: ${processingError.message}`));
          }ntId: document._id,
        } else {req.ip,
          return next(new ApiError(400, `Error processing document: ${processingError.message}`));
        }
      }
    } else {
      return next(new ApiError(400, 'Unsupported file format. Only PDF, DOCX, and DOC files are allowed'));
    }teVariables: documentData.templateVariables || [],
    tData.autoDetectedSignatureFields?.length || 0
    documentData.pageCount = pageCount;
    
    // Create document record in database
    const document = await Document.create(documentData);
    
    // Log document upload
    await Log.create({
      level: 'info',
      message: `Document uploaded with template data: ${originalname}`,
      documentId: document._id,
      ipAddress: req.ip,templateVariables || [],
      requestPath: req.originalUrl,
      requestMethod: req.method,
      metadata: {
        fileSize: size,
        mimeType: mimetype,
        templateVariables: documentData.templateVariables || [],
        templateDataKeys: Object.keys(templateData),
        autoDetectedFields: documentData.autoDetectedSignatureFields?.length || 0,
        hasProcessedFile: !!processedFilePath,
        containsAdobeSignTags: true
      }/api/documents/upload-with-data
    });
    
    logger.info(`Document uploaded with template data: ${originalname}`);
    files || (!req.files.document && !req.files.documents)) {
    // Step 2: Prepare document for signaturenew ApiError(400, 'No document uploaded'));
    let { recipients, signatureFieldMapping, signingFlow } = req.body;
    
    // If no recipients provided, try to extract from JSON template datapport both 'document' and 'documents' field names
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {mentFile = req.files.document ? req.files.document[0] : req.files.documents[0];
      if (document.templateData) {les.data[0] : null;
        logger.info('No recipients provided, extracting from template data');
        recipients = extractRecipientsFromTemplateData(document.templateData);
        { filename, originalname, mimetype, size, path: filePath } = documentFile;
        if (!recipients || recipients.length === 0) {
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));
        }mplateData = {};
        logger.info(`Extracted ${recipients.length} recipients from template data`);
        
        // Auto-generate signature field mapping from extracted recipientsst jsonContent = fs.readFileSync(dataFile.path, 'utf8');
        if (!signatureFieldMapping) {mplateData = JSON.parse(jsonContent);
          signatureFieldMapping = {};
          recipients.forEach(recipient => {
            if (recipient.signatureField) {
              signatureFieldMapping[recipient.email] = recipient.signatureField;
            }file processed with ${Object.keys(templateData).length} variables`);
          });jsonError) {
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);
        }JSON data file'));
      } else {
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));
      }
    } else if (!Array.isArray(recipients)) {body if provided instead of file
      return next(new ApiError(400, 'Recipients must be an array'));
    }
    eof req.body.templateData === 'string' 
    // Validate signing flow optioneData) 
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) 
      ? signingFlow.toUpperCase() er.error(`Error parsing JSON data from body: ${jsonError.message}`);
      : 'SEQUENTIAL'; // Default to sequential (updated default)
    
    // Validate and format recipients
    const formattedRecipients = recipients.map((recipient, index) => {
      if (!recipient.name || !recipient.email) {
        throw new ApiError(400, 'Each recipient must have a name and email');ocumentData = {
      }ilename,
      alName: originalname,
      return {
        name: recipient.name,ath,
        email: recipient.email,
        order: index + 1,
        status: 'pending',
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`
      };
    }); needs processing
    eExtension = path.extname(originalname).toLowerCase();
    // Update document with recipients and signature field mapping
    document.recipients = formattedRecipients;
    document.status = 'ready_for_signature';
    document.signatureFieldMapping = signatureFieldMapping || {};
    document.signingFlow = selectedSigningFlow;
    await document.save();ount
    
    // Log document preparation
    await Log.create({
      level: 'info',variables in text layers
      message: `Document prepared for signature: ${document.originalName}`,
      documentId: document._id,DocumentForSignatureFields(filePath);
      ipAddress: req.ip,cumentData.templateVariables = analysis.templateVariables;
      requestPath: req.originalUrl,
      requestMethod: req.method,ocumentData.autoDetectedSignatureFields = (analysis.signatureFields || []).map(field => {
      metadata: {eld === 'object' && field.name) {
        recipientCount: recipients.length
      }
    });       type: field.type.toLowerCase(),
             required: true,
    logger.info(`Document prepared for signature: ${document.originalName}`);          x: field.x,
    
    // Step 3: Send document for signature using the best approach
    // First check if we're currently rate limited by Adobe Signfield.height,
    if (rateLimitProtection.isRateLimited()) {
      const timeRemaining = rateLimitProtection.getTimeRemaining();
      const status = rateLimitProtection.getRateLimitStatus();     };
            } else {
      logger.warn(`Rate limit check failed: ${status}`);
      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));          name: field,
    }gnature',
    
    // First validate Adobe Sign configuration
    const { validateAdobeSignConfig } = require('../config/adobeSign');
    const configValidation = validateAdobeSignConfig();
    
    if (!configValidation.isValid) {ze PDF for template variables: ${analysisError.message}`);
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));ludes(fileExtension)) {
    }DOC file with template data
    
    const document = await Document.findOne({// First analyze the document
      _id: req.params.id,documentProcessor.analyzeDocumentForSignatureFields(filePath);
      status: 'ready_for_signature'
    }); // Process template with data if provided
        if (Object.keys(templateData).length > 0) {
    if (!document) {
      return next(new ApiError(404, 'Document not found or not ready for signature'));        // Use our specialized Adobe Sign tag handler to process the document
    }adobeSignTagHandler.processDocumentWithTags(filePath, templateData);
  
    if (!document.recipients || document.recipients.length === 0) {nd processing info
      return next(new ApiError(400, 'Document has no recipients'));     processedFilePath = processResult.processedFilePath;
    }fPath = processResult.pdfFilePath;
    ocessedFilePath = processedFilePath;
    // Validate recipient emails finalPdfPath;
    const invalidRecipients = document.recipients.filter(recipient => {ocessResult.hasAdobeSignTags;
      const email = recipient.email;) {
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);cument with tags: ${processingError.message}`);
    });rocessing document template: ${processingError.message}`));
     }
    if (invalidRecipients.length > 0) { } else {
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));   // No template data, just convert the original document to PDF
    }ath = await documentProcessor.convertDocxToPdf(filePath);

    try {
      // Determine which file to use for Adobe Sign     
      let fileToUpload = document.filePath;      documentData.templateVariables = analysis.templateVariables;
              documentData.documentAnalysis = analysis;
      // If document was processed from DOCX/DOC, use the PDF version     
      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {d PDF
        fileToUpload = document.pdfFilePath;t documentUtils.analyzePdf(finalPdfPath);
        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);     pageCount = pdfInfo.pageCount;
      }
       // Check if the document has Adobe Sign text tags and verify their format
      // Check if file existseFields && documentData.autoDetectedSignatureFields.length > 0) {
      if (!fs.existsSync(fileToUpload)) {ult = verifyAdobeSignTextTags(documentData.autoDetectedSignatureFields);
        logger.error(`File not found at path: ${fileToUpload}`);      if (verificationResult.hasTags) {
        return next(new ApiError(404, 'Document file not found on server')); tags detected in document');
      }  
      ctFormat) {
      // Get file stats to ensure it's not emptyr.warn('Issues found with Adobe Sign text tags:');
      const fileStats = fs.statSync(fileToUpload);       verificationResult.issuesFound.forEach(issue => logger.warn(`- ${issue}`));
      if (fileStats.size === 0) {r.warn('Recommendations:');
        logger.error(`File is empty: ${fileToUpload}`);rificationResult.recommendations.forEach(rec => logger.warn(`- ${rec}`));
        return next(new ApiError(400, 'Document file is empty'));           
      }            // If there are issues, add a message to the response
                    documentData.textTagIssues = verificationResult.issuesFound;
      // Upload as transient document           documentData.textTagRecommendations = verificationResult.recommendations;
      logger.info(`Uploading document as transient document: ${document.originalName}`);
      const transientDocumentId = await uploadTransientDocument(fileToUpload); Sign text tags verification passed - signatures should appear at tag positions');
      logger.info(`Document uploaded as transient document: ${transientDocumentId}`);         }
      
      // Ensure we have a webhook setup for status updates     documentData.hasAdobeSignTags = true;
      try {
        // Get access token
        const accessToken = await getAccessToken(); 
            logger.info(`Document processed successfully. Found ${analysis.templateVariables.length} template variables`);
        // Setup webhook URLssingError) {
        const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;ngError.message}`);
           
        // Check if webhook URL is HTTPS, which Adobe Sign requires    // Check if this might be an Adobe Sign tag related error
        const isHttps = webhookUrl.startsWith('https://');ing is "Template Error: Multi error"
        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1'); (processingError.message.includes('Multi error') || 
        const isDevEnvironment = process.env.NODE_ENV === 'development';udes('Template Error') ||
        singError.message.includes('unopened tag') ||
        if (!isHttps && process.env.NODE_ENV === 'production') {     processingError.message.includes('unclosed tag') ||
          logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);ingError.message.includes('Error: {')) {
        } 
        // Use mock implementation for development or non-HTTPS environments       try {
        else if (webhookUrl) {          logger.info('Detected potential Adobe Sign tag related error, checking document');
          try {            // Check for Adobe Sign tags in the document
            // Import our improved webhook creator that handles non-HTTPS URLs         const hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(filePath);
            const createWebhookLocal = require('../config/createWebhook');
            const webhookResult = await createWebhookLocal(accessToken, webhookUrl);
                       logger.info('Adobe Sign tags detected, using specialized processing instead');
            if (webhookResult._mockImplementation) {
              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);       // Use the specialized handler for Adobe Sign tags
            } else {entWithAdobeSignTags(filePath, templateData);
              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`);          documentData.processedFilePath = processedFilePath;
            } true;
          } catch (innerWebhookError) {
            // Log the error but continue with document sending       // Convert processed document to PDF
            logger.error(`Inner webhook error: ${innerWebhookError.message}`);          finalPdfPath = await documentProcessor.convertDocxToPdf(processedFilePath);
          }ntData.pdfFilePath = finalPdfPath;
        } else {
          logger.warn('No webhook URL configured for Adobe Sign updates');         // Analyze the converted PDF
        }              const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
      } catch (webhookError) {
        // Log the error but continue with document sending
        logger.error(`Error setting up webhook: ${webhookError.message}`);fully recovered from template error using Adobe Sign handler');
      }
      
      // Use the comprehensive approach from adobeSignFormFields utility      throw processingError;
      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);
      const result = await createAgreementWithBestApproach(
        transientDocumentId,   if (recoveryError !== processingError) {
        document.recipients,
        document.originalName,    }
        {ate: ${processingError.message}`));
          templateId: document.templateId, // If using templates
          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],
          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)ror processing document: ${processingError.message}`));
        }
      );
      
      // Update document with Adobe Sign agreement IDnext(new ApiError(400, 'Unsupported file format. Only PDF, DOCX, and DOC files are allowed'));
      document.adobeAgreementId = result.agreementId;
      document.status = 'sent_for_signature';
      document.adobeMetadata = {ta.pageCount = pageCount;
        agreementId: result.agreementId,
        method: result.method,Create document record in database
        createdAt: new Date()ocumentData);
      };
      / Log document upload
      // Special handling for rate limitingawait Log.create({
      if (result.rateLimited) {
        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);
        document.status = 'signature_error';
        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;
        document.adobeMetadata.rateLimited = true;
        document.adobeMetadata.retryAfter = result.retryAfter;  requestMethod: req.method,
        document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));
        
        await document.save();
        
        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`)); autoDetectedFields: documentData.autoDetectedSignatureFields?.length || 0
      }}
      
      // Update recipients status
      document.recipients.forEach(recipient => {ded: ${originalname}`);
        recipient.status = 'sent';
      });ormatResponse(
      
      await document.save();ocument uploaded successfully',
       
      // Log document sent for signature    document,
      await Log.create({
        level: 'info',ata.autoDetectedSignatureFields || []
        message: `Document sent for signature using ${result.method} approach: ${document.originalName}`,
        
        documentId: document._id,
        ipAddress: req.ip,
        requestPath: req.originalUrl,
        requestMethod: req.method,
        metadata: {
          adobeAgreementId: result.agreementId,
          method: result.method,
          recipientCount: document.recipients.lengthpload-with-data
        }
      });ync (req, res, next) => {
      
      logger.info(`Document sent for signature using ${result.method} approach: ${document.originalName} `);s || (!req.files.document && !req.files.documents)) {
      ocument uploaded'));
      res.status(200).json(formatResponse(
        200,
        `Document sent for signature successfully using ${result.method} approach`,// Support both 'document' and 'documents' field names
        { es.documents[0];
          document,const dataFile = req.files.data ? req.files.data[0] : null;
          adobeAgreementId: result.agreementId,
          method: result.methodract file information
        }ath: filePath } = documentFile;
      ));
    } catch (adobeError) {Parse JSON data if provided
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);a = {};
      if (adobeError.response) {) {
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);   try {
      }      const jsonContent = fs.readFileSync(dataFile.path, 'utf8');
              templateData = JSON.parse(jsonContent);
      // Update document status to indicate error     
      document.status = 'signature_error';
      document.errorMessage = adobeError.message;
      await document.save();     
      bject.keys(templateData).length} variables`);
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`)); catch (jsonError) {
    }ge}`);
  } catch (error) { JSON data file'));
    next(error);
  }
};
tead of file
/**
 * Get all documents for a user try {
 * @route GET /api/documents    templateData = typeof req.body.templateData === 'string' 
 */
exports.getDocuments = async (req, res, next) => {
  try {
    const documents = await Document.find({})    logger.error(`Error parsing JSON data from body: ${jsonError.message}`);
      .sort({ createdAt: -1 });, 'Invalid JSON data in request body'));
    
    res.status(200).json(formatResponse(
      200,
      'Documents retrieved successfully',// Initialize document data
      { documents }
    ));
  } catch (error) {
    next(error);ileSize: size,
  }  filePath,
};type,

/** templateData
 * Get a specific document    };
 * @route GET /api/documents/:id
 */
exports.getDocument = async (req, res, next) => {onst fileExtension = path.extname(originalname).toLowerCase();
  try {let finalPdfPath = filePath;
    const document = await Document.findOne({ 
      _id: req.params.id
    });
    
    if (!document) {/ Analyze PDF to get page count
      return next(new ApiError(404, 'Document not found'));  const pdfInfo = await documentUtils.analyzePdf(filePath);
    }
    
    res.status(200).json(formatResponse( // Even PDFs can have template variables in text layers
      200,      try {
      'Document retrieved successfully',onst analysis = await documentProcessor.analyzeDocumentForSignatureFields(filePath);
      { document }emplateVariables;
    ));lysis;
  } catch (error) {  documentData.autoDetectedSignatureFields = (analysis.signatureFields || []).map(field => {
    next(error);
  }
};

/**       required: true,
 * Prepare document for e-signature        x: field.x,
 * @route POST /api/documents/:id/prepare
 */
exports.prepareForSignature = async (req, res, next) => {
  try {
    let { recipients, signatureFieldMapping, signingFlow } = req.body;       detected: true
          };
    const document = await Document.findOne({
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));     };
    }    }

    // If no recipients provided, try to extract from JSON template data
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {rror.message}`);
      if (document.templateData) {
        logger.info('No recipients provided, extracting from template data');else if (['.docx', '.doc'].includes(fileExtension)) {
        recipients = extractRecipientsFromTemplateData(document.templateData);
        
        if (!recipients || recipients.length === 0) {e document
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));alyzeDocumentForSignatureFields(filePath);
        }
        logger.info(`Extracted ${recipients.length} recipients from template data`);with data if provided
        
        // Auto-generate signature field mapping from extracted recipients  try {
        if (!signatureFieldMapping) {s the document
          signatureFieldMapping = {};r.processDocumentWithTags(filePath, templateData);
          recipients.forEach(recipient => {
            if (recipient.signatureField) {
              signatureFieldMapping[recipient.email] = recipient.signatureField;    processedFilePath = processResult.processedFilePath;
            }
          });
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);  documentData.pdfFilePath = finalPdfPath;
        }
      } else {rror) {
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));ger.error(`Error processing document with tags: ${processingError.message}`);
      } ${processingError.message}`));
    } else if (!Array.isArray(recipients)) {
      return next(new ApiError(400, 'Recipients must be an array'));
    } No template data, just convert the original document to PDF
    vertDocxToPdf(filePath);
    // Validate signing flow option
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) 
      ? signingFlow.toUpperCase() entData.templateVariables = analysis.templateVariables;
      : 'SEQUENTIAL'; // Default to sequential (updated default) analysis;
    
    // Validate and format recipients
    const formattedRecipients = recipients.map((recipient, index) => {st pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
      if (!recipient.name || !recipient.email) {t = pdfInfo.pageCount;
        throw new ApiError(400, 'Each recipient must have a name and email');
      }/ Check if the document has Adobe Sign text tags and verify their format
      etectedSignatureFields && documentData.autoDetectedSignatureFields.length > 0) {
      return {s(documentData.autoDetectedSignatureFields);
        name: recipient.name,
        email: recipient.email,     logger.info('Adobe Sign text tags detected in document');
        order: index + 1,      
        status: 'pending',
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`
      };=> logger.warn(`- ${issue}`));
    });ecommendations:');
    sult.recommendations.forEach(rec => logger.warn(`- ${rec}`));
    // Update document with recipients and signature field mapping
    document.recipients = formattedRecipients;     // If there are issues, add a message to the response
    document.status = 'ready_for_signature';suesFound;
    document.signatureFieldMapping = signatureFieldMapping || {};ions;
    document.signingFlow = selectedSigningFlow;
    await document.save();     logger.info('Adobe Sign text tags verification passed - signatures should appear at tag positions');
        }
    // Log document preparation      
    await Log.create({
      level: 'info',
      message: `Document prepared for signature: ${document.originalName}`,
      documentId: document._id,
      ipAddress: req.ip,successfully. Found ${analysis.templateVariables.length} template variables`);
      requestPath: req.originalUrl,) {
      requestMethod: req.method,rocessing document: ${processingError.message}`);
      metadata: {
        recipientCount: recipients.length  // Check if this might be an Adobe Sign tag related error
      } is "Template Error: Multi error"
    });sage.includes('Multi error') || 
    
    logger.info(`Document prepared for signature: ${document.originalName}`);('unopened tag') ||
    
    // Step 3: Send document for signature using the best approachr: {')) {
    // First check if we're currently rate limited by Adobe Sign
    if (rateLimitProtection.isRateLimited()) {
      const timeRemaining = rateLimitProtection.getTimeRemaining();    logger.info('Detected potential Adobe Sign tag related error, checking document');
      const status = rateLimitProtection.getRateLimitStatus(); Sign tags in the document
          const hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(filePath);
      logger.warn(`Rate limit check failed: ${status}`);
      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));     if (hasAdobeSignTags) {
    }        logger.info('Adobe Sign tags detected, using specialized processing instead');
    
    // First validate Adobe Sign configuration Adobe Sign tags
    const { validateAdobeSignConfig } = require('../config/adobeSign');await documentProcessor.processDocumentWithAdobeSignTags(filePath, templateData);
    const configValidation = validateAdobeSignConfig();     documentData.processedFilePath = processedFilePath;
            documentData.hasAdobeSignTags = true;
    if (!configValidation.isValid) {
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);        // Convert processed document to PDF
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));entProcessor.convertDocxToPdf(processedFilePath);
    }ta.pdfFilePath = finalPdfPath;
    
    const document = await Document.findOne({
      _id: req.params.id,      const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
      status: 'ready_for_signature'.pageCount;
    });
    ly recovered from template error using Adobe Sign handler');
    if (!document) {
      return next(new ApiError(404, 'Document not found or not ready for signature')); not Adobe Sign tags, re-throw original error
    }

    if (!document.recipients || document.recipients.length === 0) {
      return next(new ApiError(400, 'Document has no recipients'));   if (recoveryError !== processingError) {
    }     logger.error(`Recovery attempt failed: ${recoveryError.message}`);
          }
    // Validate recipient emails;
    const invalidRecipients = document.recipients.filter(recipient => {    }
      const email = recipient.email;
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);turn next(new ApiError(400, `Error processing document: ${processingError.message}`));
    });
    
    if (invalidRecipients.length > 0) {
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));d file format. Only PDF, DOCX, and DOC files are allowed'));
    }

    try {entData.pageCount = pageCount;
      // Determine which file to use for Adobe Sign
      let fileToUpload = document.filePath;
      ent.create(documentData);
      // If document was processed from DOCX/DOC, use the PDF version
      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {Log document upload
        fileToUpload = document.pdfFilePath;ait Log.create({
        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);
      }nalname}`,
      
      // Check if file exists
      if (!fs.existsSync(fileToUpload)) {requestPath: req.originalUrl,
        logger.error(`File not found at path: ${fileToUpload}`);
        return next(new ApiError(404, 'Document file not found on server')); metadata: {
      }ize,
      : mimetype,
      // Get file stats to ensure it's not empty     templateVariables: documentData.templateVariables || [],
      const fileStats = fs.statSync(fileToUpload);      autoDetectedFields: documentData.autoDetectedSignatureFields?.length || 0
      if (fileStats.size === 0) {      }
        logger.error(`File is empty: ${fileToUpload}`); });
        return next(new ApiError(400, 'Document file is empty'));
      }riginalname}`);
       
      // Upload as transient document
      logger.info(`Uploading document as transient document: ${document.originalName}`);01,
      const transientDocumentId = await uploadTransientDocument(fileToUpload);
      logger.info(`Document uploaded as transient document: ${transientDocumentId}`);
       document,
      // Ensure we have a webhook setup for status updates    templateVariables: documentData.templateVariables || [],
      try {SignatureFields: documentData.autoDetectedSignatureFields || []
        // Get access token
        const accessToken = await getAccessToken(););
        catch (error) {
        // Setup webhook URL
        const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;
        
        // Check if webhook URL is HTTPS, which Adobe Sign requires
        const isHttps = webhookUrl.startsWith('https://');
        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');
        const isDevEnvironment = process.env.NODE_ENV === 'development';
        
        if (!isHttps && process.env.NODE_ENV === 'production') {.uploadDocumentWithData = async (req, res, next) => {
          logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);{
        } eq.files.documents)) {
        // Use mock implementation for development or non-HTTPS environments
        else if (webhookUrl) {
          try {
            // Import our improved webhook creator that handles non-HTTPS URLsupport both 'document' and 'documents' field names
            const createWebhookLocal = require('../config/createWebhook');s.document[0] : req.files.documents[0];
            const webhookResult = await createWebhookLocal(accessToken, webhookUrl);req.files.data[0] : null;
            
            if (webhookResult._mockImplementation) {
              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);mimetype, size, path: filePath } = documentFile;
            } else {
              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`);
            }
          } catch (innerWebhookError) {
            // Log the error but continue with document sending{
            logger.error(`Inner webhook error: ${innerWebhookError.message}`);onst jsonContent = fs.readFileSync(dataFile.path, 'utf8');
          }  templateData = JSON.parse(jsonContent);
        } else {
          logger.warn('No webhook URL configured for Adobe Sign updates');
        }
      } catch (webhookError) {
        // Log the error but continue with document sendingObject.keys(templateData).length} variables`);
        logger.error(`Error setting up webhook: ${webhookError.message}`); catch (jsonError) {
      }  logger.error(`Error parsing JSON data: ${jsonError.message}`);
      t(new ApiError(400, 'Invalid JSON data file'));
      // Use the comprehensive approach from adobeSignFormFields utility}
      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);    }
      const result = await createAgreementWithBestApproach(
        transientDocumentId,dy if provided instead of file
        document.recipients,
        document.originalName,try {
        { req.body.templateData === 'string' 
          templateId: document.templateId, // If using templates
          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],    : req.body.templateData;
          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)
        }y: ${jsonError.message}`);
      );  return next(new ApiError(400, 'Invalid JSON data in request body'));
      
      // Update document with Adobe Sign agreement ID
      document.adobeAgreementId = result.agreementId;
      document.status = 'sent_for_signature';
      document.adobeMetadata = {
        agreementId: result.agreementId,
        method: result.method,,
        createdAt: new Date()
      };ilePath,
      mimeType: mimetype,
      // Special handling for rate limiting
      if (result.rateLimited) {
        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);
        document.status = 'signature_error';
        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;
        document.adobeMetadata.rateLimited = true;
        document.adobeMetadata.retryAfter = result.retryAfter;th;
        document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));
         processedFilePath = null;
        await document.save();
        
        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`)); page count
      } pdfInfo = await documentUtils.analyzePdf(filePath);
      
      // Update recipients status
      document.recipients.forEach(recipient => { Even PDFs can have template variables in text layers
        recipient.status = 'sent';
      });cessor.analyzeDocumentForSignatureFields(filePath);
      eVariables;
      await document.save();
      ds || []).map(field => {
      // Log document sent for signature(typeof field === 'object' && field.name) {
      await Log.create({eturn {
        level: 'info',   name: field.name,
        message: `Document sent for signature using ${result.method} approach: ${document.originalName}`,      type: field.type.toLowerCase(),
        
        documentId: document._id,      x: field.x,
        ipAddress: req.ip,
        requestPath: req.originalUrl,
        requestMethod: req.method,
        metadata: {
          adobeAgreementId: result.agreementId,    detected: true
          method: result.method,
          recipientCount: document.recipients.length
        }
      });
      
      logger.info(`Document sent for signature using ${result.method} approach: ${document.originalName} `);
      
      res.status(200).json(formatResponse(
        200,
        `Document sent for signature successfully using ${result.method} approach`,
        { 
          document,
          adobeAgreementId: result.agreementId,if (['.docx', '.doc'].includes(fileExtension)) {
          method: result.method Process DOCX/DOC file with template data
        }
      ));ocument
    } catch (adobeError) {ocumentProcessor.analyzeDocumentForSignatureFields(filePath);
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);
      if (adobeError.response) {/ Process template with data if provided
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);mplateData).length > 0) {
      }
          // Use our specialized Adobe Sign tag handler to process the document
      // Update document status to indicate errormentWithTags(filePath, templateData);
      document.status = 'signature_error';
      document.errorMessage = adobeError.message;ith paths and processing info
      await document.save();
      
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`)); documentData.processedFilePath = processedFilePath;
    } documentData.pdfFilePath = finalPdfPath;
  } catch (error) {     documentData.hasAdobeSignTags = processResult.hasAdobeSignTags;
    next(error);    } catch (processingError) {
  }: ${processingError.message}`);
};sing document template: ${processingError.message}`));

/**
 * Get all documents for a user
 * @route GET /api/documents  finalPdfPath = await documentProcessor.convertDocxToPdf(filePath);
 */
exports.getDocuments = async (req, res, next) => {
  try {
    const documents = await Document.find({})mentData.templateVariables = analysis.templateVariables;
      .sort({ createdAt: -1 });tAnalysis = analysis;
    
    res.status(200).json(formatResponse(
      200,pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
      'Documents retrieved successfully',
      { documents }
    ));ck if the document has Adobe Sign text tags and verify their format
  } catch (error) {elds.length > 0) {
    next(error);ags(documentData.autoDetectedSignatureFields);
  }
};

/**) {
 * Get a specific documentogger.warn('Issues found with Adobe Sign text tags:');
 * @route GET /api/documents/:idverificationResult.issuesFound.forEach(issue => logger.warn(`- ${issue}`));
 */
exports.getDocument = async (req, res, next) => {ions.forEach(rec => logger.warn(`- ${rec}`));
  try {
    const document = await Document.findOne({ onse
      _id: req.params.idesFound;
    });ommendations;
    
    if (!document) {Sign text tags verification passed - signatures should appear at tag positions');
      return next(new ApiError(404, 'Document not found'));
    }
    ntData.hasAdobeSignTags = true;
    res.status(200).json(formatResponse(
      200,
      'Document retrieved successfully',
      { document }gth} template variables`);
    ));ocessingError) {
  } catch (error) {
    next(error);
  }
};ate Error: Multi error"
ge.includes('Multi error') || 
/**Template Error') ||
 * Prepare document for e-signature
 * @route POST /api/documents/:id/preparesingError.message.includes('unclosed tag') ||
 */essingError.message.includes('Error: {')) {
exports.prepareForSignature = async (req, res, next) => {
  try {
    let { recipients, signatureFieldMapping, signingFlow } = req.body;
    eck for Adobe Sign tags in the document
    const document = await Document.findOne({t documentProcessor.containsAdobeSignTags(filePath);
      _id: req.params.id
    });
    ogger.info('Adobe Sign tags detected, using specialized processing instead');
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }essDocumentWithAdobeSignTags(filePath, templateData);

    // If no recipients provided, try to extract from JSON template datacumentData.hasAdobeSignTags = true;
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {
      if (document.templateData) { to PDF
        logger.info('No recipients provided, extracting from template data');
        recipients = extractRecipientsFromTemplateData(document.templateData);mentData.pdfFilePath = finalPdfPath;
        
        if (!recipients || recipients.length === 0) {
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));f(finalPdfPath);
        }
        logger.info(`Extracted ${recipients.length} recipients from template data`);
        ger.info('Successfully recovered from template error using Adobe Sign handler');
        // Auto-generate signature field mapping from extracted recipientsse {
        if (!signatureFieldMapping) {
          signatureFieldMapping = {};
          recipients.forEach(recipient => {
            if (recipient.signatureField) {
              signatureFieldMapping[recipient.email] = recipient.signatureField;r) {
            }r.message}`);
          });
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);plate: ${processingError.message}`));
        }
      } else {
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));ext(new ApiError(400, `Error processing document: ${processingError.message}`));
      }
    } else if (!Array.isArray(recipients)) {
      return next(new ApiError(400, 'Recipients must be an array'));
    }iles are allowed'));
    
    // Validate signing flow option
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) 
      ? signingFlow.toUpperCase() 
      : 'SEQUENTIAL'; // Default to sequential (updated default)
    
    // Validate and format recipientsnt upload
    const formattedRecipients = recipients.map((recipient, index) => {eate({
      if (!recipient.name || !recipient.email) {
        throw new ApiError(400, 'Each recipient must have a name and email');`,
      }
      
      return {
        name: recipient.name, req.method,
        email: recipient.email,
        order: index + 1,
        status: 'pending',
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`es || [],
      };eFields?.length || 0
    });
    
    // Update document with recipients and signature field mapping
    document.recipients = formattedRecipients;
    document.status = 'ready_for_signature';
    document.signatureFieldMapping = signatureFieldMapping || {};
    document.signingFlow = selectedSigningFlow;
    await document.save();ded successfully',
    
    // Log document preparation
    await Log.create({ || [],
      level: 'info',
      message: `Document prepared for signature: ${document.originalName}`,
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,
      requestMethod: req.method,
      metadata: {
        recipientCount: recipients.length
      }
    });sing
    -data
    logger.info(`Document prepared for signature: ${document.originalName}`);
    cumentWithData = async (req, res, next) => {
    // Step 3: Send document for signature using the best approach
    // First check if we're currently rate limited by Adobe Sign && !req.files.documents)) {
    if (rateLimitProtection.isRateLimited()) {
      const timeRemaining = rateLimitProtection.getTimeRemaining();
      const status = rateLimitProtection.getRateLimitStatus();
      
      logger.warn(`Rate limit check failed: ${status}`);eq.files.documents[0];
      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));
    }
    file information
    // First validate Adobe Sign configurationlename, originalname, mimetype, size, path: filePath } = documentFile;
    const { validateAdobeSignConfig } = require('../config/adobeSign');
    const configValidation = validateAdobeSignConfig();
    
    if (!configValidation.isValid) {
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));jsonContent = fs.readFileSync(dataFile.path, 'utf8');
    }
    
    const document = await Document.findOne({
      _id: req.params.id,
      status: 'ready_for_signature'
    });
    
    if (!document) {ror(`Error parsing JSON data: ${jsonError.message}`);
      return next(new ApiError(404, 'Document not found or not ready for signature'));
    }

    if (!document.recipients || document.recipients.length === 0) {
      return next(new ApiError(400, 'Document has no recipients'));est body if provided instead of file
    }
    
    // Validate recipient emailsata === 'string' 
    const invalidRecipients = document.recipients.filter(recipient => {
      const email = recipient.email;
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    });e}`);
    ew ApiError(400, 'Invalid JSON data in request body'));
    if (invalidRecipients.length > 0) {
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));
    }

    try {
      // Determine which file to use for Adobe Sign
      let fileToUpload = document.filePath;
      
      // If document was processed from DOCX/DOC, use the PDF version
      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {
        fileToUpload = document.pdfFilePath;
        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);
      }
      
      // Check if file exists or needs processing
      if (!fs.existsSync(fileToUpload)) {xtname(originalname).toLowerCase();
        logger.error(`File not found at path: ${fileToUpload}`);
        return next(new ApiError(404, 'Document file not found on server'));
      }
      
      // Get file stats to ensure it's not empty
      const fileStats = fs.statSync(fileToUpload);
      if (fileStats.size === 0) {
        logger.error(`File is empty: ${fileToUpload}`);fo.pageCount;
        return next(new ApiError(400, 'Document file is empty'));
      }template variables in text layers
      
      // Upload as transient documentreFields(filePath);
      logger.info(`Uploading document as transient document: ${document.originalName}`);
      const transientDocumentId = await uploadTransientDocument(fileToUpload);
      logger.info(`Document uploaded as transient document: ${transientDocumentId}`);eFields = (analysis.signatureFields || []).map(field => {
       {
      // Ensure we have a webhook setup for status updates
      try {name,
        // Get access tokend.type.toLowerCase(),
        const accessToken = await getAccessToken();
        
        // Setup webhook URL
        const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;
        
        // Check if webhook URL is HTTPS, which Adobe Sign requires
        const isHttps = webhookUrl.startsWith('https://');e
        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');
        const isDevEnvironment = process.env.NODE_ENV === 'development';
        
        if (!isHttps && process.env.NODE_ENV === 'production') {
          logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);ature',
        } 
        // Use mock implementation for development or non-HTTPS environments
        else if (webhookUrl) {
          try {
            // Import our improved webhook creator that handles non-HTTPS URLsisError) {
            const createWebhookLocal = require('../config/createWebhook'); not analyze PDF for template variables: ${analysisError.message}`);
            const webhookResult = await createWebhookLocal(accessToken, webhookUrl);
            ension)) {
            if (webhookResult._mockImplementation) {
              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);
            } else {
              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`);nalyzeDocumentForSignatureFields(filePath);
            }
          } catch (innerWebhookError) {
            // Log the error but continue with document sendingmplateData).length > 0) {
            logger.error(`Inner webhook error: ${innerWebhookError.message}`);
          }tag handler to process the document
        } else {esult = await adobeSignTagHandler.processDocumentWithTags(filePath, templateData);
          logger.warn('No webhook URL configured for Adobe Sign updates');
        }
      } catch (webhookError) {
        // Log the error but continue with document sending processResult.pdfFilePath;
        logger.error(`Error setting up webhook: ${webhookError.message}`);entData.processedFilePath = processedFilePath;
      }umentData.pdfFilePath = finalPdfPath;
      cumentData.hasAdobeSignTags = processResult.hasAdobeSignTags;
      // Use the comprehensive approach from adobeSignFormFields utility
      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);ssage}`);
      const result = await createAgreementWithBestApproach(
        transientDocumentId,
        document.recipients,
        document.originalName,document to PDF
        {
          templateId: document.templateId, // If using templatesfPath;
          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],
          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)
        }emplateVariables = analysis.templateVariables;
      );ysis;
      
      // Update document with Adobe Sign agreement ID
      document.adobeAgreementId = result.agreementId;await documentUtils.analyzePdf(finalPdfPath);
      document.status = 'sent_for_signature';
      document.adobeMetadata = {
        agreementId: result.agreementId,k if the document has Adobe Sign text tags and verify their format
        method: result.method,cumentData.autoDetectedSignatureFields && documentData.autoDetectedSignatureFields.length > 0) {
        createdAt: new Date()
      };(verificationResult.hasTags) {
      ogger.info('Adobe Sign text tags detected in document');
      // Special handling for rate limiting 
      if (result.rateLimited) {     if (!verificationResult.correctFormat) {
        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);        logger.warn('Issues found with Adobe Sign text tags:');
        document.status = 'signature_error';ogger.warn(`- ${issue}`));
        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;
        document.adobeMetadata.rateLimited = true;${rec}`));
        document.adobeMetadata.retryAfter = result.retryAfter;
        document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));    // If there are issues, add a message to the response
        sFound;
        await document.save();mentData.textTagRecommendations = verificationResult.recommendations;
        
        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));gs verification passed - signatures should appear at tag positions');
      }
      
      // Update recipients status= true;
      document.recipients.forEach(recipient => {
        recipient.status = 'sent';
      });
      template variables`);
      await document.save();h (processingError) {
      ger.error(`Error processing document: ${processingError.message}`);
      // Log document sent for signature
      await Log.create({tag related error
        level: 'info',
        message: `Document sent for signature using ${result.method} approach: ${document.originalName}`,
          processingError.message.includes('Template Error') ||
        documentId: document._id,
        ipAddress: req.ip,
        requestPath: req.originalUrl,  processingError.message.includes('Error: {')) {
        requestMethod: req.method,
        metadata: {
          adobeAgreementId: result.agreementId,   logger.info('Detected potential Adobe Sign tag related error, checking document');
          method: result.method,     // Check for Adobe Sign tags in the document
          recipientCount: document.recipients.length      const hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(filePath);
        }
      });
              logger.info('Adobe Sign tags detected, using specialized processing instead');
      logger.info(`Document sent for signature using ${result.method} approach: ${document.originalName} `);
      
      res.status(200).json(formatResponse(.processDocumentWithAdobeSignTags(filePath, templateData);
        200,        documentData.processedFilePath = processedFilePath;
        `Document sent for signature successfully using ${result.method} approach`,true;
        { 
          document,        // Convert processed document to PDF
          adobeAgreementId: result.agreementId,rtDocxToPdf(processedFilePath);
          method: result.methoddfFilePath = finalPdfPath;
        }
      ));
    } catch (adobeError) {mentUtils.analyzePdf(finalPdfPath);
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);
      if (adobeError.response) {
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);('Successfully recovered from template error using Adobe Sign handler');
      }
       If not Adobe Sign tags, re-throw original error
      // Update document status to indicate errorcessingError;
      document.status = 'signature_error';
      document.errorMessage = adobeError.message;h (recoveryError) {
      await document.save(); processingError) {
      Error.message}`);
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`));
    }nt template: ${processingError.message}`));
  } catch (error) {
    next(error);
  } `Error processing document: ${processingError.message}`));
};

/**
 * Get all documents for a userle format. Only PDF, DOCX, and DOC files are allowed'));
 * @route GET /api/documents
 */
exports.getDocuments = async (req, res, next) => {t = pageCount;
  try {
    const documents = await Document.find({})
      .sort({ createdAt: -1 });nt = await Document.create(documentData);
    
    res.status(200).json(formatResponse(
      200,
      'Documents retrieved successfully',
      { documents }
    ));
  } catch (error) {
    next(error);
  }stMethod: req.method,
};
: size,
/** mimeType: mimetype,
 * Get a specific document  templateVariables: documentData.templateVariables || [],
 * @route GET /api/documents/:id
 */
exports.getDocument = async (req, res, next) => {
  try {
    const document = await Document.findOne({ originalname}`);
      _id: req.params.id
    });s.status(201).json(formatResponse(
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    } document,
      templateVariables: documentData.templateVariables || [],
    res.status(200).json(formatResponse(s: documentData.autoDetectedSignatureFields || []
      200,
      'Document retrieved successfully',;
      { document }
    ));
  } catch (error) {
    next(error);
  }
};
or template processing
/**ad-with-data
 * Prepare document for e-signature
 * @route POST /api/documents/:id/prepareWithData = async (req, res, next) => {
 */
exports.prepareForSignature = async (req, res, next) => {q.files.document && !req.files.documents)) {
  try {ocument uploaded'));
    let { recipients, signatureFieldMapping, signingFlow } = req.body;
    
    const document = await Document.findOne({ Support both 'document' and 'documents' field names
      _id: req.params.ideq.files.documents[0];
    });nst dataFile = req.files.data ? req.files.data[0] : null;
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));lePath } = documentFile;
    }

    // If no recipients provided, try to extract from JSON template data
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {
      if (document.templateData) {
        logger.info('No recipients provided, extracting from template data');dFileSync(dataFile.path, 'utf8');
        recipients = extractRecipientsFromTemplateData(document.templateData);
        
        if (!recipients || recipients.length === 0) {/ Clean up the temporary JSON file
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));fs.unlinkSync(dataFile.path);
        }
        logger.info(`Extracted ${recipients.length} recipients from template data`); ${Object.keys(templateData).length} variables`);
        
        // Auto-generate signature field mapping from extracted recipientslogger.error(`Error parsing JSON data: ${jsonError.message}`);
        if (!signatureFieldMapping) {ext(new ApiError(400, 'Invalid JSON data file'));
          signatureFieldMapping = {};
          recipients.forEach(recipient => {
            if (recipient.signatureField) {
              signatureFieldMapping[recipient.email] = recipient.signatureField;y if provided instead of file
            }plateData) {
          });
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);emplateData === 'string' 
        }
      } else {
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));tch (jsonError) {
      }ogger.error(`Error parsing JSON data from body: ${jsonError.message}`);
    } else if (!Array.isArray(recipients)) {  return next(new ApiError(400, 'Invalid JSON data in request body'));
      return next(new ApiError(400, 'Recipients must be an array'));
    }
    
    // Validate signing flow option
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) lename,
      ? signingFlow.toUpperCase()       originalName: originalname,
      : 'SEQUENTIAL'; // Default to sequential (updated default)
    th,
    // Validate and format recipients
    const formattedRecipients = recipients.map((recipient, index) => {us: 'uploaded',
      if (!recipient.name || !recipient.email) {
        throw new ApiError(400, 'Each recipient must have a name and email');
      }
      r needs processing
      return {= path.extname(originalname).toLowerCase();
        name: recipient.name,
        email: recipient.email,
        order: index + 1,essedFilePath = null;
        status: 'pending',
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`ileExtension === '.pdf') {
      };Analyze PDF to get page count
    }); await documentUtils.analyzePdf(filePath);
    
    // Update document with recipients and signature field mapping
    document.recipients = formattedRecipients; template variables in text layers
    document.status = 'ready_for_signature';
    document.signatureFieldMapping = signatureFieldMapping || {}; const analysis = await documentProcessor.analyzeDocumentForSignatureFields(filePath);
    document.signingFlow = selectedSigningFlow;  documentData.templateVariables = analysis.templateVariables;
    await document.save();
       documentData.autoDetectedSignatureFields = (analysis.signatureFields || []).map(field => {
    // Log document preparationf field === 'object' && field.name) {
    await Log.create({rn {
      level: 'info',           name: field.name,
      message: `Document prepared for signature: ${document.originalName}`,            type: field.type.toLowerCase(),
      documentId: document._id,              required: true,
      ipAddress: req.ip,           x: field.x,
      requestPath: req.originalUrl,
      requestMethod: req.method,
      metadata: {           height: field.height,
        recipientCount: recipients.length
      }       detected: true
    });
    
    logger.info(`Document prepared for signature: ${document.originalName}`);            return {
    field,
    // Step 3: Send document for signature using the best approach
    // First check if we're currently rate limited by Adobe Signed: true
    if (rateLimitProtection.isRateLimited()) {
      const timeRemaining = rateLimitProtection.getTimeRemaining();     }
      const status = rateLimitProtection.getRateLimitStatus();        });
      
      logger.warn(`Rate limit check failed: ${status}`);e PDF for template variables: ${analysisError.message}`);
      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));
    } else if (['.docx', '.doc'].includes(fileExtension)) {
          // Process DOCX/DOC file with template data
    // First validate Adobe Sign configuration
    const { validateAdobeSignConfig } = require('../config/adobeSign');
    const configValidation = validateAdobeSignConfig();    const analysis = await documentProcessor.analyzeDocumentForSignatureFields(filePath);
    
    if (!configValidation.isValid) {plate with data if provided
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);f (Object.keys(templateData).length > 0) {
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));
    }
          const processResult = await adobeSignTagHandler.processDocumentWithTags(filePath, templateData);
    const document = await Document.findOne({
      _id: req.params.id,
      status: 'ready_for_signature'      processedFilePath = processResult.processedFilePath;
    });
    Path;
    if (!document) {
      return next(new ApiError(404, 'Document not found or not ready for signature'));sResult.hasAdobeSignTags;
    }
    logger.error(`Error processing document with tags: ${processingError.message}`);
    if (!document.recipients || document.recipients.length === 0) {singError.message}`));
      return next(new ApiError(400, 'Document has no recipients'));
    }
    
    // Validate recipient emailsDocxToPdf(filePath);
    const invalidRecipients = document.recipients.filter(recipient => {
      const email = recipient.email;
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    });ocumentData.templateVariables = analysis.templateVariables;
     documentData.documentAnalysis = analysis;
    if (invalidRecipients.length > 0) {
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));
    }  const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);

    try {
      // Determine which file to use for Adobe Signeir format
      let fileToUpload = document.filePath;gth > 0) {
      s);
      // If document was processed from DOCX/DOC, use the PDF versiont.hasTags) {
      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {
        fileToUpload = document.pdfFilePath;
        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);     if (!verificationResult.correctFormat) {
      }         logger.warn('Issues found with Adobe Sign text tags:');
                    verificationResult.issuesFound.forEach(issue => logger.warn(`- ${issue}`));
      // Check if file exists
      if (!fs.existsSync(fileToUpload)) {${rec}`));
        logger.error(`File not found at path: ${fileToUpload}`);
        return next(new ApiError(404, 'Document file not found on server'));          // If there are issues, add a message to the response
      }     documentData.textTagIssues = verificationResult.issuesFound;
      
      // Get file stats to ensure it's not empty      } else {
      const fileStats = fs.statSync(fileToUpload); signatures should appear at tag positions');
      if (fileStats.size === 0) {
        logger.error(`File is empty: ${fileToUpload}`);
        return next(new ApiError(400, 'Document file is empty'));
      }
      
      // Upload as transient document  
      logger.info(`Uploading document as transient document: ${document.originalName}`);sfully. Found ${analysis.templateVariables.length} template variables`);
      const transientDocumentId = await uploadTransientDocument(fileToUpload);
      logger.info(`Document uploaded as transient document: ${transientDocumentId}`);.error(`Error processing document: ${processingError.message}`);
      
      // Ensure we have a webhook setup for status updates
      try {or: Multi error"
        // Get access token
        const accessToken = await getAccessToken();
        rocessingError.message.includes('unopened tag') ||
        // Setup webhook URL   processingError.message.includes('unclosed tag') ||
        const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;     processingError.message.includes('Error: {')) {
            
        // Check if webhook URL is HTTPS, which Adobe Sign requires
        const isHttps = webhookUrl.startsWith('https://');document');
        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');cument
        const isDevEnvironment = process.env.NODE_ENV === 'development';await documentProcessor.containsAdobeSignTags(filePath);
               
        if (!isHttps && process.env.NODE_ENV === 'production') {            if (hasAdobeSignTags) {
          logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);tected, using specialized processing instead');
        } 
        // Use mock implementation for development or non-HTTPS environments
        else if (webhookUrl) { await documentProcessor.processDocumentWithAdobeSignTags(filePath, templateData);
          try {          documentData.processedFilePath = processedFilePath;
            // Import our improved webhook creator that handles non-HTTPS URLsrue;
            const createWebhookLocal = require('../config/createWebhook');
            const webhookResult = await createWebhookLocal(accessToken, webhookUrl);processed document to PDF
                      finalPdfPath = await documentProcessor.convertDocxToPdf(processedFilePath);
            if (webhookResult._mockImplementation) {
              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);
            } else {
              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`);        const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
            }
          } catch (innerWebhookError) {
            // Log the error but continue with document sendingrom template error using Adobe Sign handler');
            logger.error(`Inner webhook error: ${innerWebhookError.message}`);
          }         // If not Adobe Sign tags, re-throw original error
        } else {              throw processingError;
          logger.warn('No webhook URL configured for Adobe Sign updates');
        }
      } catch (webhookError) {!== processingError) {
        // Log the error but continue with document sending
        logger.error(`Error setting up webhook: ${webhookError.message}`);      }
      }template: ${processingError.message}`));
      
      // Use the comprehensive approach from adobeSignFormFields utility
      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);or.message}`));
      const result = await createAgreementWithBestApproach(}
        transientDocumentId,
        document.recipients,
        document.originalName,ext(new ApiError(400, 'Unsupported file format. Only PDF, DOCX, and DOC files are allowed'));
        {
          templateId: document.templateId, // If using templates
          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],unt;
          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)
        } database
      );
      
      // Update document with Adobe Sign agreement ID
      document.adobeAgreementId = result.agreementId;
      document.status = 'sent_for_signature';
      document.adobeMetadata = { `Document uploaded: ${originalname}`,
        agreementId: result.agreementId,
        method: result.method,
        createdAt: new Date()
      };hod,
      
      // Special handling for rate limiting
      if (result.rateLimited) {
        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);ta.templateVariables || [],
        document.status = 'signature_error';tectedFields: documentData.autoDetectedSignatureFields?.length || 0
        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;
        document.adobeMetadata.rateLimited = true;
        document.adobeMetadata.retryAfter = result.retryAfter;
        document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));
        
        await document.save();esponse(
        
        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));d successfully',
      }
      
      // Update recipients status
      document.recipients.forEach(recipient => {
        recipient.status = 'sent';
      });
      
      await document.save();
      
      // Log document sent for signature
      await Log.create({
        level: 'info',
        message: `Document sent for signature using ${result.method} approach: ${document.originalName}`, endpoint: Upload document with data, prepare, and send for signature
        te POST /api/documents/upload-and-send
        documentId: document._id,
        ipAddress: req.ip,
        requestPath: req.originalUrl,
        requestMethod: req.method, Step 1: Upload and process document (reuse uploadDocumentWithData logic)
        metadata: {uments)) {
          adobeAgreementId: result.agreementId,
          method: result.method,
          recipientCount: document.recipients.length
        }port both 'document' and 'documents' field names
      });t documentFile = req.files.document ? req.files.document[0] : req.files.documents[0];
      null;
      logger.info(`Document sent for signature using ${result.method} approach: ${document.originalName} `);
      
      res.status(200).json(formatResponse(t { filename, originalname, mimetype, size, path: filePath } = documentFile;
        200,
        `Document sent for signature successfully using ${result.method} approach`,
        { a = {};
          document,ataFile) {
          adobeAgreementId: result.agreementId,y {
          method: result.method
        }
      ));
    } catch (adobeError) {SON file
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);th);
      if (adobeError.response) {
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);sed with ${Object.keys(templateData).length} variables`);
      }
       JSON data: ${jsonError.message}`);
      // Update document status to indicate errord JSON data file'));
      document.status = 'signature_error';
      document.errorMessage = adobeError.message;
      await document.save();
      
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`));ateData) {
    }
  } catch (error) {  templateData = typeof req.body.templateData === 'string' 
    next(error);
  }
};
ogger.error(`Error parsing JSON data from body: ${jsonError.message}`);
/**   return next(new ApiError(400, 'Invalid JSON data in request body'));
 * Get all documents for a user  }
 * @route GET /api/documents
 */
exports.getDocuments = async (req, res, next) => {
  try {
    const documents = await Document.find({})  filename,
      .sort({ createdAt: -1 });
    
    res.status(200).json(formatResponse(
      200, mimeType: mimetype,
      'Documents retrieved successfully',
      { documents }
    ));
  } catch (error) {
    next(error);Check if it's a PDF or needs processing
  }onst fileExtension = path.extname(originalname).toLowerCase();
};

/**
 * Get a specific document
 * @route GET /api/documents/:id
 */ const pdfInfo = await documentUtils.analyzePdf(filePath);
exports.getDocument = async (req, res, next) => {  pageCount = pdfInfo.pageCount;
  try { {
    const document = await Document.findOne({ 
      _id: req.params.id  try {
    });
    ureFields(filePath);
    if (!document) {
      return next(new ApiError(404, 'Document not found'));= analysis.templateVariables;
    }    documentData.documentAnalysis = analysis;
    
    res.status(200).json(formatResponse(
      200,or.containsAdobeSignTags(filePath);
      'Document retrieved successfully',
      { document }
    ));     logger.info('Detected Adobe Sign tags in document, using direct bypass processing');
  } catch (error) {
    next(error);
  }
};vation

/**         logger.info('Using direct bypass approach for Adobe Sign tags');
 * Prepare document for e-signatureateProcessing(filePath, templateData);
 * @route POST /api/documents/:id/prepare
 */ToPdf(processedFilePath);
exports.prepareForSignature = async (req, res, next) => {
  try {age}, trying specialized handler...`);
    let { recipients, signatureFieldMapping, signingFlow } = req.body;         // Fall back to the specialized handler
    ocumentWithAdobeSignTags(filePath, templateData);
    const document = await Document.findOne({
      _id: req.params.idrtDocxToPdf(processedFilePath);
    });
    
    if (!document) {       // No template data, just convert to PDF
      return next(new ApiError(404, 'Document not found'));        finalPdfPath = await documentProcessor.convertDocxToPdf(filePath);
    }

    // If no recipients provided, try to extract from JSON template data
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {
      if (document.templateData) {       processedFilePath = await documentProcessor.processDocumentTemplate(filePath, templateData);
        logger.info('No recipients provided, extracting from template data');            documentData.processedFilePath = processedFilePath;
        recipients = extractRecipientsFromTemplateData(document.templateData);
        
        if (!recipients || recipients.length === 0) {
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));
        }
        logger.info(`Extracted ${recipients.length} recipients from template data`);
        
        // Auto-generate signature field mapping from extracted recipients> {
        if (!signatureFieldMapping) {
          signatureFieldMapping = {};       // Field is an object with positioning data - extract the proper structure for Adobe Sign
          recipients.forEach(recipient => {        return {
            if (recipient.signatureField) {
              signatureFieldMapping[recipient.email] = recipient.signatureField;
            }
          });        x: field.x,
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);
        }
      } else {
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));
      }ted: true
    } else if (!Array.isArray(recipients)) {   };
      return next(new ApiError(400, 'Recipients must be an array'));  } else {
    }
    
    // Validate signing flow option
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase())     required: true
      ? signingFlow.toUpperCase() 
      : 'SEQUENTIAL'; // Default to sequential (updated default)
    
    // Validate and format recipients
    const formattedRecipients = recipients.map((recipient, index) => {
      if (!recipient.name || !recipient.email) {
        throw new ApiError(400, 'Each recipient must have a name and email');
      }
      ags and verify their format
      return {& documentData.autoDetectedSignatureFields.length > 0) {
        name: recipient.name,umentData.autoDetectedSignatureFields);
        email: recipient.email,
        order: index + 1,
        status: 'pending',
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`
      };gn text tags:');
    });    verificationResult.issuesFound.forEach(issue => logger.warn(`- ${issue}`));
    
    // Update document with recipients and signature field mappingsult.recommendations.forEach(rec => logger.warn(`- ${rec}`));
    document.recipients = formattedRecipients;
    document.status = 'ready_for_signature';onse
    document.signatureFieldMapping = signatureFieldMapping || {};uesFound;
    document.signingFlow = selectedSigningFlow;esult.recommendations;
    await document.save();
    ation passed - signatures should appear at tag positions');
    // Log document preparation
    await Log.create({
      level: 'info',  documentData.hasAdobeSignTags = true;
      message: `Document prepared for signature: ${document.originalName}`,
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,ully. Found ${analysis.templateVariables.length} template variables`);
      requestMethod: req.method,
      metadata: {processingError.message}`);
        recipientCount: recipients.length
      }ag related error
    });Template Error: Multi error"
    ulti error') || 
    logger.info(`Document prepared for signature: ${document.originalName}`);Template Error') ||
      processingError.message.includes('unopened tag') ||
    // Step 3: Send document for signature using the best approach
    // First check if we're currently rate limited by Adobe Signr.message.includes('Error: {')) {
    if (rateLimitProtection.isRateLimited()) {
      const timeRemaining = rateLimitProtection.getTimeRemaining();y {
      const status = rateLimitProtection.getRateLimitStatus();');
      gs in the document
      logger.warn(`Rate limit check failed: ${status}`);tProcessor.containsAdobeSignTags(filePath);
      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));
    }
    ed, using specialized processing instead');
    // First validate Adobe Sign configuration
    const { validateAdobeSignConfig } = require('../config/adobeSign'); the specialized handler for Adobe Sign tags
    const configValidation = validateAdobeSignConfig();dobeSignTags(filePath, templateData);
    
    if (!configValidation.isValid) { documentData.hasAdobeSignTags = true;
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);  
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));ocument to PDF
    }mentProcessor.convertDocxToPdf(processedFilePath);
    
    const document = await Document.findOne({
      _id: req.params.id,
      status: 'ready_for_signature'Utils.analyzePdf(finalPdfPath);
    });nt;
    
    if (!document) {  logger.info('Successfully recovered from template error using Adobe Sign handler');
      return next(new ApiError(404, 'Document not found or not ready for signature'));
    }riginal error

    if (!document.recipients || document.recipients.length === 0) {
      return next(new ApiError(400, 'Document has no recipients'));atch (recoveryError) {
    }or) {
    recoveryError.message}`);
    // Validate recipient emails
    const invalidRecipients = document.recipients.filter(recipient => { next(new ApiError(400, `Error processing document template: ${processingError.message}`));
      const email = recipient.email;
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);lse {
    }); return next(new ApiError(400, `Error processing document: ${processingError.message}`));
     }
    if (invalidRecipients.length > 0) {}
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));
    }nly PDF, DOCX, and DOC files are allowed'));

    try {
      // Determine which file to use for Adobe Sign
      let fileToUpload = document.filePath;
      
      // If document was processed from DOCX/DOC, use the PDF version
      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {
        fileToUpload = document.pdfFilePath;
        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);
      }
      
      // Check if file exists
      if (!fs.existsSync(fileToUpload)) {
        logger.error(`File not found at path: ${fileToUpload}`);
        return next(new ApiError(404, 'Document file not found on server'));
      }
      e: size,
      // Get file stats to ensure it's not emptyype: mimetype,
      const fileStats = fs.statSync(fileToUpload);plateVariables: documentData.templateVariables || [],
      if (fileStats.size === 0) {utoDetectedFields: documentData.autoDetectedSignatureFields?.length || 0
        logger.error(`File is empty: ${fileToUpload}`);
        return next(new ApiError(400, 'Document file is empty'));
      }
      
      // Upload as transient document
      logger.info(`Uploading document as transient document: ${document.originalName}`);
      const transientDocumentId = await uploadTransientDocument(fileToUpload);
      logger.info(`Document uploaded as transient document: ${transientDocumentId}`);'Document uploaded successfully',
      
      // Ensure we have a webhook setup for status updates
      try {
        // Get access tokentectedSignatureFields || []
        const accessToken = await getAccessToken();
        
        // Setup webhook URL
        const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;
        
        // Check if webhook URL is HTTPS, which Adobe Sign requires
        const isHttps = webhookUrl.startsWith('https://');
        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');
        const isDevEnvironment = process.env.NODE_ENV === 'development';
        
        if (!isHttps && process.env.NODE_ENV === 'production') {
          logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);
        } 
        // Use mock implementation for development or non-HTTPS environments
        else if (webhookUrl) {
          try {'));
            // Import our improved webhook creator that handles non-HTTPS URLs
            const createWebhookLocal = require('../config/createWebhook');
            const webhookResult = await createWebhookLocal(accessToken, webhookUrl);
            documents[0];
            if (webhookResult._mockImplementation) {s.data[0] : null;
              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);
            } else {t file information
              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`); filename, originalname, mimetype, size, path: filePath } = documentFile;
            }
          } catch (innerWebhookError) {Parse JSON data if provided
            // Log the error but continue with document sendingt templateData = {};
            logger.error(`Inner webhook error: ${innerWebhookError.message}`);
          }
        } else {eadFileSync(dataFile.path, 'utf8');
          logger.warn('No webhook URL configured for Adobe Sign updates');templateData = JSON.parse(jsonContent);
        }
      } catch (webhookError) {
        // Log the error but continue with document sending
        logger.error(`Error setting up webhook: ${webhookError.message}`);
      }
      
      // Use the comprehensive approach from adobeSignFormFields utilitygger.error(`Error parsing JSON data: ${jsonError.message}`);
      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);w ApiError(400, 'Invalid JSON data file'));
      const result = await createAgreementWithBestApproach(
        transientDocumentId,
        document.recipients,
        document.originalName,
        {
          templateId: document.templateId, // If using templates
          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],teData === 'string' 
          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)
        }q.body.templateData;
      );
      arsing JSON data from body: ${jsonError.message}`);
      // Update document with Adobe Sign agreement IDError(400, 'Invalid JSON data in request body'));
      document.adobeAgreementId = result.agreementId;
      document.status = 'sent_for_signature';
      document.adobeMetadata = {
        agreementId: result.agreementId,
        method: result.method,ata = {
        createdAt: new Date(),
      };
      e: size,
      // Special handling for rate limitingath,
      if (result.rateLimited) {eType: mimetype,
        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);'uploaded',
        document.status = 'signature_error';
        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;
        document.adobeMetadata.rateLimited = true;
        document.adobeMetadata.retryAfter = result.retryAfter;heck if it's a PDF or needs processing
        document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));
        
        await document.save();geCount = 0;
        
        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));
      }
      
      // Update recipients statust = pdfInfo.pageCount;
      document.recipients.forEach(recipient => {des(fileExtension)) {
        recipient.status = 'sent';
      });
      
      await document.save();ntProcessor.analyzeDocumentForSignatureFields(filePath);
      
      // Log document sent for signatureata.templateVariables = analysis.templateVariables;
      await Log.create({entData.documentAnalysis = analysis;
        level: 'info',
        message: `Document sent for signature using ${result.method} approach: ${document.originalName}`, for Adobe Sign tags before attempting standard processing
        
        documentId: document._id,
        ipAddress: req.ip, if (hasAdobeSignTags) {
        requestPath: req.originalUrl,     logger.info('Detected Adobe Sign tags in document, using direct bypass processing');
        requestMethod: req.method,      documentData.containsAdobeSignTags = true;
        metadata: {
          adobeAgreementId: result.agreementId,
          method: result.method,ation
          recipientCount: document.recipients.length
        }gs');
      });          processedFilePath = await adobeSignBypass.bypassTemplateProcessing(filePath, templateData);
      
      logger.info(`Document sent for signature using ${result.method} approach: ${document.originalName} `);
      
      res.status(200).json(formatResponse(        logger.warn(`Direct bypass failed: ${bypassError.message}, trying specialized handler...`);
        200,
        `Document sent for signature successfully using ${result.method} approach`,wait documentProcessor.processDocumentWithAdobeSignTags(filePath, templateData);
        {         documentData.processedFilePath = processedFilePath;
          document,lePath);
          adobeAgreementId: result.agreementId,
          method: result.method
        }
      ));cxToPdf(filePath);
    } catch (adobeError) {
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);
      if (adobeError.response) {path (no Adobe Sign tags)
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);gth > 0) {
      } processedFilePath = await documentProcessor.processDocumentTemplate(filePath, templateData);
          documentData.processedFilePath = processedFilePath;
      // Update document status to indicate error
      document.status = 'signature_error';   } else {
      document.errorMessage = adobeError.message;      finalPdfPath = await documentProcessor.convertDocxToPdf(filePath);
      await document.save();
      
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`));
    }
  } catch (error) {d => {
    next(error); if (typeof field === 'object' && field.name) {
  }     // Field is an object with positioning data - extract the proper structure for Adobe Sign
};      return {

/**         type: field.type.toLowerCase(),
 * Get all documents for a user          required: true,
 * @route GET /api/documents
 */
exports.getDocuments = async (req, res, next) => {
  try {
    const documents = await Document.find({})         page: field.page,
      .sort({ createdAt: -1 });              detected: true
    
    res.status(200).json(formatResponse(
      200,        // Fallback for string-based fields
      'Documents retrieved successfully',
      { documents }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Get a specific document   const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
 * @route GET /api/documents/:id    pageCount = pdfInfo.pageCount;
 */
exports.getDocument = async (req, res, next) => {mat
  try {
    const document = await Document.findOne({ atureFields);
      _id: req.params.id    if (verificationResult.hasTags) {
    });in document');
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));       logger.warn('Issues found with Adobe Sign text tags:');
    }forEach(issue => logger.warn(`- ${issue}`));
    
    res.status(200).json(formatResponse(       verificationResult.recommendations.forEach(rec => logger.warn(`- ${rec}`));
      200,         
      'Document retrieved successfully',          // If there are issues, add a message to the response
      { document }ssues = verificationResult.issuesFound;
    ));TagRecommendations = verificationResult.recommendations;
  } catch (error) {
    next(error);xt tags verification passed - signatures should appear at tag positions');
  }
};
ntData.hasAdobeSignTags = true;
/**    }
 * Prepare document for e-signature    }
 * @route POST /api/documents/:id/prepare
 */und ${analysis.templateVariables.length} template variables`);
exports.prepareForSignature = async (req, res, next) => {
  try {: ${processingError.message}`);
    let { recipients, signatureFieldMapping, signingFlow } = req.body;
     Adobe Sign tag related error
    const document = await Document.findOne({ "Template Error: Multi error"
      _id: req.params.idlti error') || 
    });mplate Error') ||
    ned tag') ||
    if (!document) {losed tag') ||
      return next(new ApiError(404, 'Document not found'));rror: {')) {
    }

    // If no recipients provided, try to extract from JSON template datal Adobe Sign tag related error, checking document');
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) { // Check for Adobe Sign tags in the document
      if (document.templateData) {   const hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(filePath);
        logger.info('No recipients provided, extracting from template data');   
        recipients = extractRecipientsFromTemplateData(document.templateData);     if (hasAdobeSignTags) {
                 logger.info('Adobe Sign tags detected, using specialized processing instead');
        if (!recipients || recipients.length === 0) {          
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));
        }          processedFilePath = await documentProcessor.processDocumentWithAdobeSignTags(filePath, templateData);
        logger.info(`Extracted ${recipients.length} recipients from template data`);ilePath;
        Tags = true;
        // Auto-generate signature field mapping from extracted recipients
        if (!signatureFieldMapping) {
          signatureFieldMapping = {};
          recipients.forEach(recipient => {     documentData.pdfFilePath = finalPdfPath;
            if (recipient.signatureField) {         
              signatureFieldMapping[recipient.email] = recipient.signatureField;          // Analyze the converted PDF
            }
          });
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);
        }          logger.info('Successfully recovered from template error using Adobe Sign handler');
      } else {
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));
      }
    } else if (!Array.isArray(recipients)) {      }
      return next(new ApiError(400, 'Recipients must be an array'));      } catch (recoveryError) {
    }ssingError) {
    
    // Validate signing flow option
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) 
      ? signingFlow.toUpperCase() } else {
      : 'SEQUENTIAL'; // Default to sequential (updated default)ngError.message}`));
    
    // Validate and format recipients
    const formattedRecipients = recipients.map((recipient, index) => {
      if (!recipient.name || !recipient.email) {
        throw new ApiError(400, 'Each recipient must have a name and email');
      }
      
      return {
        name: recipient.name,base
        email: recipient.email,document = await Document.create(documentData);
        order: index + 1,
        status: 'pending',
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`
      };
    });age: `Document uploaded: ${originalname}`,
    cumentId: document._id,
    // Update document with recipients and signature field mapping
    document.recipients = formattedRecipients;
    document.status = 'ready_for_signature';
    document.signatureFieldMapping = signatureFieldMapping || {};{
    document.signingFlow = selectedSigningFlow;
    await document.save();
    emplateVariables: documentData.templateVariables || [],
    // Log document preparationautoDetectedFields: documentData.autoDetectedSignatureFields?.length || 0
    await Log.create({
      level: 'info',
      message: `Document prepared for signature: ${document.originalName}`,
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,s(201).json(formatResponse(
      requestMethod: req.method,,
      metadata: {ocument uploaded successfully',
        recipientCount: recipients.length
      }
    });
    tureFields: documentData.autoDetectedSignatureFields || []
    logger.info(`Document prepared for signature: ${document.originalName}`);
    
    // Step 3: Send document for signature using the best approach
    // First check if we're currently rate limited by Adobe Sign
    if (rateLimitProtection.isRateLimited()) {
      const timeRemaining = rateLimitProtection.getTimeRemaining();
      const status = rateLimitProtection.getRateLimitStatus();
      
      logger.warn(`Rate limit check failed: ${status}`); signature
      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));
    }
    
    // First validate Adobe Sign configuration
    const { validateAdobeSignConfig } = require('../config/adobeSign');
    const configValidation = validateAdobeSignConfig();
    
    if (!configValidation.isValid) {
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));port both 'document' and 'documents' field names
    }cuments[0];
    q.files.data[0] : null;
    const document = await Document.findOne({
      _id: req.params.id,ract file information
      status: 'ready_for_signature'
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found or not ready for signature'));
    }
'utf8');
    if (!document.recipients || document.recipients.length === 0) {ontent);
      return next(new ApiError(400, 'Document has no recipients'));
    } file
    
    // Validate recipient emails
    const invalidRecipients = document.recipients.filter(recipient => {gger.info(`JSON data file processed with ${Object.keys(templateData).length} variables`);
      const email = recipient.email;
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);}`);
    });
    
    if (invalidRecipients.length > 0) {
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));
    }

    try {
      // Determine which file to use for Adobe SigntemplateData === 'string' 
      let fileToUpload = document.filePath;
      
      // If document was processed from DOCX/DOC, use the PDF version
      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {
        fileToUpload = document.pdfFilePath;SON data in request body'));
        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);
      }
      
      // Check if file exists document data
      if (!fs.existsSync(fileToUpload)) {
        logger.error(`File not found at path: ${fileToUpload}`);
        return next(new ApiError(404, 'Document file not found on server'));
      }e: size,
      ath,
      // Get file stats to ensure it's not emptyType: mimetype,
      const fileStats = fs.statSync(fileToUpload);
      if (fileStats.size === 0) {
        logger.error(`File is empty: ${fileToUpload}`);
        return next(new ApiError(400, 'Document file is empty'));
      }ck if it's a PDF or needs processing
      oLowerCase();
      // Upload as transient document
      logger.info(`Uploading document as transient document: ${document.originalName}`);
      const transientDocumentId = await uploadTransientDocument(fileToUpload);
      logger.info(`Document uploaded as transient document: ${transientDocumentId}`);
      nalyze PDF to get page count
      // Ensure we have a webhook setup for status updates
      try {
        // Get access tokenf (['.docx', '.doc'].includes(fileExtension)) {
        const accessToken = await getAccessToken();
        
        // Setup webhook URLnalysis and processing logic for DOCX/DOC
        const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;Processor.analyzeDocumentForSignatureFields(filePath);
        
        // Check if webhook URL is HTTPS, which Adobe Sign requires
        const isHttps = webhookUrl.startsWith('https://');ntData.documentAnalysis = analysis;
        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');
        const isDevEnvironment = process.env.NODE_ENV === 'development';
        hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(filePath);
        if (!isHttps && process.env.NODE_ENV === 'production') {
          logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);SignTags) {
        } 
        // Use mock implementation for development or non-HTTPS environmentsmentData.containsAdobeSignTags = true;
        else if (webhookUrl) {
          try {
            // Import our improved webhook creator that handles non-HTTPS URLsag preservation
            const createWebhookLocal = require('../config/createWebhook');
            const webhookResult = await createWebhookLocal(accessToken, webhookUrl);
            ass.bypassTemplateProcessing(filePath, templateData);
            if (webhookResult._mockImplementation) {ocumentData.processedFilePath = processedFilePath;
              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`); finalPdfPath = await adobeSignBypass.convertToPdf(processedFilePath);
            } else {} catch (bypassError) {
              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`);er.warn(`Direct bypass failed: ${bypassError.message}, trying specialized handler...`);
            }r
          } catch (innerWebhookError) {thAdobeSignTags(filePath, templateData);
            // Log the error but continue with document sending  documentData.processedFilePath = processedFilePath;
            logger.error(`Inner webhook error: ${innerWebhookError.message}`);dFilePath);
          }
        } else {
          logger.warn('No webhook URL configured for Adobe Sign updates'); No template data, just convert to PDF
        }finalPdfPath = await documentProcessor.convertDocxToPdf(filePath);
      } catch (webhookError) {
        // Log the error but continue with document sending
        logger.error(`Error setting up webhook: ${webhookError.message}`);be Sign tags)
      }
      dFilePath = await documentProcessor.processDocumentTemplate(filePath, templateData);
      // Use the comprehensive approach from adobeSignFormFields utility
      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);nalPdfPath = await documentProcessor.convertDocxToPdf(processedFilePath);
      const result = await createAgreementWithBestApproach(
        transientDocumentId,ocxToPdf(filePath);
        document.recipients,
        document.originalName,
        {
          templateId: document.templateId, // If using templatestData.pdfFilePath = finalPdfPath;
          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],entData.autoDetectedSignatureFields = (analysis.signatureFields || []).map(field => {
          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)f (typeof field === 'object' && field.name) {
        }   // Field is an object with positioning data - extract the proper structure for Adobe Sign
      );        return {
      
      // Update document with Adobe Sign agreement ID          type: field.type.toLowerCase(),
      document.adobeAgreementId = result.agreementId;
      document.status = 'sent_for_signature';
      document.adobeMetadata = {
        agreementId: result.agreementId,
        method: result.method,height: field.height,
        createdAt: new Date()
      };  detected: true
      
      // Special handling for rate limiting
      if (result.rateLimited) {g-based fields
        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);
        document.status = 'signature_error';   name: field,
        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;   type: 'signature',
        document.adobeMetadata.rateLimited = true;       required: true
        document.adobeMetadata.retryAfter = result.retryAfter;      };
        document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));
        
        await document.save();
         Analyze the converted PDF
        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));lyzePdf(finalPdfPath);
      }ount;
      
      // Update recipients status Sign text tags and verify their format
      document.recipients.forEach(recipient => {toDetectedSignatureFields && documentData.autoDetectedSignatureFields.length > 0) {
        recipient.status = 'sent'; const verificationResult = verifyAdobeSignTextTags(documentData.autoDetectedSignatureFields);
      }); if (verificationResult.hasTags) {
             logger.info('Adobe Sign text tags detected in document');
      await document.save();            
      
      // Log document sent for signatured with Adobe Sign text tags:');
      await Log.create({ach(issue => logger.warn(`- ${issue}`));
        level: 'info',
        message: `Document sent for signature using ${result.method} approach: ${document.originalName}`,=> logger.warn(`- ${rec}`));
        
        documentId: document._id,       // If there are issues, add a message to the response
        ipAddress: req.ip,         documentData.textTagIssues = verificationResult.issuesFound;
        requestPath: req.originalUrl,              documentData.textTagRecommendations = verificationResult.recommendations;
        requestMethod: req.method,
        metadata: {obe Sign text tags verification passed - signatures should appear at tag positions');
          adobeAgreementId: result.agreementId,
          method: result.method,        
          recipientCount: document.recipients.length   documentData.hasAdobeSignTags = true;
        }
      });  }
      
      logger.info(`Document sent for signature using ${result.method} approach: ${document.originalName} `);
      
      res.status(200).json(formatResponse(  logger.error(`Error processing document: ${processingError.message}`);
        200,
        `Document sent for signature successfully using ${result.method} approach`,
        {   // The specific error you're seeing is "Template Error: Multi error"
          document,(processingError.message.includes('Multi error') || 
          adobeAgreementId: result.agreementId,
          method: result.method
        }.message.includes('unclosed tag') ||
      ));rror.message.includes('Error: {')) {
    } catch (adobeError) {
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);
      if (adobeError.response) {hecking document');
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);  // Check for Adobe Sign tags in the document
      }    const hasAdobeSignTags = await documentProcessor.containsAdobeSignTags(filePath);
      
      // Update document status to indicate errorTags) {
      document.status = 'signature_error';      logger.info('Adobe Sign tags detected, using specialized processing instead');
      document.errorMessage = adobeError.message;
      await document.save();ndler for Adobe Sign tags
            processedFilePath = await documentProcessor.processDocumentWithAdobeSignTags(filePath, templateData);
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`));essedFilePath;
    }
  } catch (error) {
    next(error);cessed document to PDF
  }nvertDocxToPdf(processedFilePath);
};
   
/**     // Analyze the converted PDF
 * Get all documents for a user      const pdfInfo = await documentUtils.analyzePdf(finalPdfPath);
 * @route GET /api/documents
 */
exports.getDocuments = async (req, res, next) => {or using Adobe Sign handler');
  try {    } else {
    const documents = await Document.find({})ror
      .sort({ createdAt: -1 });Error;
    
    res.status(200).json(formatResponse(veryError) {
      200,
      'Documents retrieved successfully',      logger.error(`Recovery attempt failed: ${recoveryError.message}`);
      { documents }
    ));piError(400, `Error processing document template: ${processingError.message}`));
  } catch (error) {
    next(error);
  } return next(new ApiError(400, `Error processing document: ${processingError.message}`));
};}

/**
 * Get a specific documenteturn next(new ApiError(400, 'Unsupported file format. Only PDF, DOCX, and DOC files are allowed'));
 * @route GET /api/documents/:id
 */
exports.getDocument = async (req, res, next) => {cumentData.pageCount = pageCount;
  try {
    const document = await Document.findOne({ rd in database
      _id: req.params.id
    });
    Log document upload
    if (!document) {ait Log.create({
      return next(new ApiError(404, 'Document not found'));
    }
     documentId: document._id,
    res.status(200).json(formatResponse(      ipAddress: req.ip,
      200,originalUrl,
      'Document retrieved successfully',d,
      { document }
    ));
  } catch (error) {
    next(error);mentData.templateVariables || [],
  }tedSignatureFields?.length || 0
};

/**
 * Prepare document for e-signaturement uploaded: ${originalname}`);
 * @route POST /api/documents/:id/prepare
 */Signature logic)
exports.prepareForSignature = async (req, res, next) => { { recipients, signatureFieldMapping, signingFlow } = req.body;
  try {
    let { recipients, signatureFieldMapping, signingFlow } = req.body;// If no recipients provided, try to extract from JSON template data
    ray.isArray(recipients) && recipients.length === 0)) {
    const document = await Document.findOne({  if (document.templateData) {
      _id: req.params.idplate data');
    });cument.templateData);
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));nts are required either in request body or template data. No recipients found in template data.'));
    }
recipients.length} recipients from template data`);
    // If no recipients provided, try to extract from JSON template data
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {
      if (document.templateData) {{
        logger.info('No recipients provided, extracting from template data');natureFieldMapping = {};
        recipients = extractRecipientsFromTemplateData(document.templateData); recipients.forEach(recipient => {
        
        if (!recipients || recipients.length === 0) {      signatureFieldMapping[recipient.email] = recipient.signatureField;
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));
        }
        logger.info(`Extracted ${recipients.length} recipients from template data`);nature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);
        
        // Auto-generate signature field mapping from extracted recipients
        if (!signatureFieldMapping) {equired either in request body or template data'));
          signatureFieldMapping = {};
          recipients.forEach(recipient => {
            if (recipient.signatureField) {n array'));
              signatureFieldMapping[recipient.email] = recipient.signatureField;
            }
          });date signing flow option
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
        }es(signingFlow.toUpperCase()) 
      } else {e() 
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));
      }
    } else if (!Array.isArray(recipients)) {nts
      return next(new ApiError(400, 'Recipients must be an array'));
    }recipient.name || !recipient.email) {
    hrow new ApiError(400, 'Each recipient must have a name and email');
    // Validate signing flow option
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) eturn {
      ? signingFlow.toUpperCase()    name: recipient.name,
      : 'SEQUENTIAL'; // Default to sequential (updated default)    email: recipient.email,
     1,
    // Validate and format recipients
    const formattedRecipients = recipients.map((recipient, index) => {gnatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`
      if (!recipient.name || !recipient.email) {
        throw new ApiError(400, 'Each recipient must have a name and email');
      }
      
      return {
        name: recipient.name,ument.status = 'ready_for_signature';
        email: recipient.email, || {};
        order: index + 1,= selectedSigningFlow;
        status: 'pending',();
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`
      };nature: ${document.originalName}`);
    });
    ogic)
    // Update document with recipients and signature field mappingre currently rate limited by Adobe Sign
    document.recipients = formattedRecipients;tion.isRateLimited()) {
    document.status = 'ready_for_signature'; rateLimitProtection.getTimeRemaining();
    document.signatureFieldMapping = signatureFieldMapping || {};etRateLimitStatus();
    document.signingFlow = selectedSigningFlow;
    await document.save();mit check failed: ${status}`);
     ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));
    // Log document preparation
    await Log.create({
      level: 'info',gn configuration
      message: `Document prepared for signature: ${document.originalName}`,../config/adobeSign');
      documentId: document._id,);
      ipAddress: req.ip,
      requestPath: req.originalUrl,
      requestMethod: req.method,tion validation failed:', configValidation.errors);
      metadata: {(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));
        recipientCount: recipients.length
      }
    });s
    cipient => {
    logger.info(`Document prepared for signature: ${document.originalName}`);
    
    // Step 3: Send document for signature using the best approach
    // First check if we're currently rate limited by Adobe Sign
    if (rateLimitProtection.isRateLimited()) {
      const timeRemaining = rateLimitProtection.getTimeRemaining();xt(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));
      const status = rateLimitProtection.getRateLimitStatus();
      
      logger.warn(`Rate limit check failed: ${status}`);
      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));le to use for Adobe Sign
    }filePath;
    
    // First validate Adobe Sign configuration
    const { validateAdobeSignConfig } = require('../config/adobeSign');document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {
    const configValidation = validateAdobeSignConfig();
    lePath}`);
    if (!configValidation.isValid) {
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));ts
    }
    .error(`File not found at path: ${fileToUpload}`);
    const document = await Document.findOne({ on server'));
      _id: req.params.id,
      status: 'ready_for_signature'
    });tats to ensure it's not empty
    
    if (!document) {
      return next(new ApiError(404, 'Document not found or not ready for signature'));
    }t(new ApiError(400, 'Document file is empty'));

    if (!document.recipients || document.recipients.length === 0) {
      return next(new ApiError(400, 'Document has no recipients'));/ Upload as transient document
    }ogger.info(`Uploading document as transient document: ${document.originalName}`);
       const transientDocumentId = await uploadTransientDocument(fileToUpload);
    // Validate recipient emails  logger.info(`Document uploaded as transient document: ${transientDocumentId}`);
    const invalidRecipients = document.recipients.filter(recipient => {
      const email = recipient.email;
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    });     // Get access token
          const accessToken = await getAccessToken();
    if (invalidRecipients.length > 0) {        
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));     // Setup webhook URL
    }BE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;

    try {     // Check if webhook URL is HTTPS, which Adobe Sign requires
      // Determine which file to use for Adobe Signs://');
      let fileToUpload = document.filePath; const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');
       = process.env.NODE_ENV === 'development';
      // If document was processed from DOCX/DOC, use the PDF version
      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {        if (!isHttps && process.env.NODE_ENV === 'production') {
        fileToUpload = document.pdfFilePath;n(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);
        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);
      }implementation for development or non-HTTPS environments
      
      // Check if file exists     try {
      if (!fs.existsSync(fileToUpload)) {            // Import our improved webhook creator that handles non-HTTPS URLs
        logger.error(`File not found at path: ${fileToUpload}`);onfig/createWebhook');
        return next(new ApiError(404, 'Document file not found on server'));it createWebhookLocal(accessToken, webhookUrl);
      }
             if (webhookResult._mockImplementation) {
      // Get file stats to ensure it's not empty              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);
      const fileStats = fs.statSync(fileToUpload);
      if (fileStats.size === 0) {or Adobe Sign: ${webhookUrl}`);
        logger.error(`File is empty: ${fileToUpload}`);        }
        return next(new ApiError(400, 'Document file is empty')); } catch (innerWebhookError) {
      }ing
      
      // Upload as transient document    }
      logger.info(`Uploading document as transient document: ${document.originalName}`);
      const transientDocumentId = await uploadTransientDocument(fileToUpload);
      logger.info(`Document uploaded as transient document: ${transientDocumentId}`); }
      } catch (webhookError) {
      // Ensure we have a webhook setup for status updates
      try {or(`Error setting up webhook: ${webhookError.message}`);
        // Get access token
        const accessToken = await getAccessToken();
         Use the comprehensive approach from adobeSignFormFields utility
        // Setup webhook URLeement: ${document.originalName}`);
        const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;thBestApproach(
        
        // Check if webhook URL is HTTPS, which Adobe Sign requires
        const isHttps = webhookUrl.startsWith('https://');
        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');
        const isDevEnvironment = process.env.NODE_ENV === 'development';teId: document.templateId, // If using templates
        DetectedSignatureFields || [],
        if (!isHttps && process.env.NODE_ENV === 'production') {TIAL' // Pass the signing flow option (default to sequential)
          logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);
        } 
        // Use mock implementation for development or non-HTTPS environments
        else if (webhookUrl) {ent with Adobe Sign agreement ID
          try {t.agreementId;
            // Import our improved webhook creator that handles non-HTTPS URLs
            const createWebhookLocal = require('../config/createWebhook');etadata = {
            const webhookResult = await createWebhookLocal(accessToken, webhookUrl);result.agreementId,
            esult.method,
            if (webhookResult._mockImplementation) {t: new Date()
              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);
            } else {
              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`);ate limiting
            }
          } catch (innerWebhookError) {reached. Retry after ${result.retryAfter} seconds.`);
            // Log the error but continue with document sendingtatus = 'signature_error';
            logger.error(`Inner webhook error: ${innerWebhookError.message}`);.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;
          }
        } else {Metadata.retryAfter = result.retryAfter;
          logger.warn('No webhook URL configured for Adobe Sign updates');t.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));
        }
      } catch (webhookError) {
        // Log the error but continue with document sending
        logger.error(`Error setting up webhook: ${webhookError.message}`);eturn next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));
      }
      
      // Use the comprehensive approach from adobeSignFormFields utility
      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);ument.recipients.forEach(recipient => {
      const result = await createAgreementWithBestApproach(recipient.status = 'sent';
        transientDocumentId,
        document.recipients,
        document.originalName,it document.save();
        {
          templateId: document.templateId, // If using templatesore signing URLs for all recipients
          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],
          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)n = await getAccessToken();
        }essToken, document.adobeAgreementId);
      );
      ntSets) {
      // Update document with Adobe Sign agreement IDt their signing URLs
      document.adobeAgreementId = result.agreementId; recipient of document.recipients) {
      document.status = 'sent_for_signature';onst participantSet of agreementInfo.participantSets) {
      document.adobeMetadata = {tSet.memberInfos) {
        agreementId: result.agreementId,     if (participant.email.toLowerCase() === recipient.email.toLowerCase()) {
        method: result.method,       try {
        createdAt: new Date()            // Get signing URL for this participant
      };ingUrlResponse = await getSigningUrl(
                    accessToken, 
      // Special handling for rate limiting
      if (result.rateLimited) {        participant.participantId
        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);
        document.status = 'signature_error';         
        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;(signingUrlResponse.signingUrlSetInfos && 
        document.adobeMetadata.rateLimited = true;signingUrlResponse.signingUrlSetInfos[0] && 
        document.adobeMetadata.retryAfter = result.retryAfter;    signingUrlResponse.signingUrlSetInfos[0].signingUrls && 
        document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));UrlResponse.signingUrlSetInfos[0].signingUrls[0]) {
                
        await document.save();ecipient.signingUrl = signingUrlResponse.signingUrlSetInfos[0].signingUrls[0].esignUrl;
        fo(`Stored signing URL for ${recipient.email}`);
        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));
      }
             logger.error(`Error getting signing URL for ${recipient.email}: ${signingUrlError.message}`);
      // Update recipients status         // Continue with other recipients even if one fails
      document.recipients.forEach(recipient => {       }
        recipient.status = 'sent';    break;
      });
      
      await document.save();
      
      // Log document sent for signature  
      await Log.create({ated signing URLs
        level: 'info',
        message: `Document sent for signature using ${result.method} approach: ${document.originalName}`,
        
        documentId: document._id, ${signingUrlError.message}`);
        ipAddress: req.ip,ved later if needed
        requestPath: req.originalUrl,
        requestMethod: req.method,
        metadata: {
          adobeAgreementId: result.agreementId,
          method: result.method,fo',
          recipientCount: document.recipients.length `Document uploaded, prepared, and sent for signature using ${result.method} approach: ${document.originalName}`,
        }
      });
      
      logger.info(`Document sent for signature using ${result.method} approach: ${document.originalName} `); req.method,
      a: {
      res.status(200).json(formatResponse(beAgreementId: result.agreementId,
        200,
        `Document sent for signature successfully using ${result.method} approach`,ecipientCount: document.recipients.length,
        {  combined_operation: true
          document,}
          adobeAgreementId: result.agreementId,
          method: result.method
        }o(`Document uploaded, prepared, and sent for signature using ${result.method} approach: ${document.originalName}`);
      ));
    } catch (adobeError) {tus(201).json(formatResponse(
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);
      if (adobeError.response) {d, prepared, and sent for signature successfully using ${result.method} approach`,
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);
      }
      
      // Update document status to indicate errord: result.method,
      document.status = 'signature_error';ningUrls: document.recipients.map(r => ({
      document.errorMessage = adobeError.message;mail: r.email,
      await document.save();   signingUrl: r.signingUrl
        })).filter(r => r.signingUrl)
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`));
    }
  } catch (error) { {
    next(error);;
  }
};beError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);

/**
 * Get all documents for a user indicate error
 * @route GET /api/documents
 */ent.errorMessage = adobeError.message;
exports.getDocuments = async (req, res, next) => { document.save();
  try {
    const documents = await Document.find({})(500, `Failed to send document for signature: ${adobeError.message}`));
      .sort({ createdAt: -1 });
    
    res.status(200).json(formatResponse();
      200,
      'Documents retrieved successfully',
      { documents }
    ));
  } catch (error) {
    next(error);
  }
};async (req, res, next) => {

/**{})
 * Get a specific document
 * @route GET /api/documents/:id
 */tus(200).json(formatResponse(
exports.getDocument = async (req, res, next) => {
  try {Documents retrieved successfully',
    const document = await Document.findOne({ 
      _id: req.params.id
    });
    ext(error);
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }
    
    res.status(200).json(formatResponse( Get a specific document
      200, * @route GET /api/documents/:id
      'Document retrieved successfully',
      { document } next) => {
    ));
  } catch (error) { const document = await Document.findOne({ 
    next(error);
  }
};
    if (!document) {
/**w ApiError(404, 'Document not found'));
 * Prepare document for e-signature
 * @route POST /api/documents/:id/prepare
 */
exports.prepareForSignature = async (req, res, next) => { 200,
  try {      'Document retrieved successfully',
    let { recipients, signatureFieldMapping, signingFlow } = req.body;
    
    const document = await Document.findOne({
      _id: req.params.idext(error);
    });  }
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }e document for e-signature

    // If no recipients provided, try to extract from JSON template data
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {s.prepareForSignature = async (req, res, next) => {
      if (document.templateData) {
        logger.info('No recipients provided, extracting from template data');
        recipients = extractRecipientsFromTemplateData(document.templateData);
        nst document = await Document.findOne({
        if (!recipients || recipients.length === 0) {
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));;
        }
        logger.info(`Extracted ${recipients.length} recipients from template data`);
        
        // Auto-generate signature field mapping from extracted recipients
        if (!signatureFieldMapping) {
          signatureFieldMapping = {};o extract from JSON template data
          recipients.forEach(recipient => {== 0)) {
            if (recipient.signatureField) {
              signatureFieldMapping[recipient.email] = recipient.signatureField;g from template data');
            }ents = extractRecipientsFromTemplateData(document.templateData);
          });
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);.length === 0) {
        }s are required either in request body or template data. No recipients found in template data.'));
      } else {
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));plate data`);
      }
    } else if (!Array.isArray(recipients)) {erate signature field mapping from extracted recipients
      return next(new ApiError(400, 'Recipients must be an array'));
    }
    cipient => {
    // Validate signing flow option
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];nt.email] = recipient.signatureField;
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) 
      ? signingFlow.toUpperCase() 
      : 'SEQUENTIAL'; // Default to sequential (updated default)ing).length} recipients`);
    
    // Validate and format recipients
    const formattedRecipients = recipients.map((recipient, index) => {s are required either in request body or template data'));
      if (!recipient.name || !recipient.email) {
        throw new ApiError(400, 'Each recipient must have a name and email');!Array.isArray(recipients)) {
      }next(new ApiError(400, 'Recipients must be an array'));
      
      return {
        name: recipient.name,date signing flow option
        email: recipient.email, validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
        order: index + 1,st selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) 
        status: 'pending',? signingFlow.toUpperCase() 
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`Default to sequential (updated default)
      };
    });rmat recipients
    
    // Update document with recipients and signature field mapping.email) {
    document.recipients = formattedRecipients;Each recipient must have a name and email');
    document.status = 'ready_for_signature';
    document.signatureFieldMapping = signatureFieldMapping || {};
    document.signingFlow = selectedSigningFlow;
    await document.save();
    mail: recipient.email,
    // Log document preparationrder: index + 1,
    await Log.create({  status: 'pending',
      level: 'info',pient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`
      message: `Document prepared for signature: ${document.originalName}`,};
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,nature field mapping
      requestMethod: req.method,ent.recipients = formattedRecipients;
      metadata: { 'ready_for_signature';
        recipientCount: recipients.lengtheFieldMapping = signatureFieldMapping || {};
      }lectedSigningFlow;
    });
    
    logger.info(`Document prepared for signature: ${document.originalName}`);
    og.create({
    // Step 3: Send document for signature using the best approachel: 'info',
    // First check if we're currently rate limited by Adobe Signsage: `Document prepared for signature: ${document.originalName}`,
    if (rateLimitProtection.isRateLimited()) {ument._id,
      const timeRemaining = rateLimitProtection.getTimeRemaining();
      const status = rateLimitProtection.getRateLimitStatus();
       requestMethod: req.method,
      logger.warn(`Rate limit check failed: ${status}`);
      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));
    }
     });
    // First validate Adobe Sign configuration  
    const { validateAdobeSignConfig } = require('../config/adobeSign');    logger.info(`Document prepared for signature: ${document.originalName}`);
    const configValidation = validateAdobeSignConfig(); 
    json(formatResponse(
    if (!configValidation.isValid) {
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);   'Document prepared for signature successfully',
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));
    }
    
    const document = await Document.findOne({
      _id: req.params.id,  }
      status: 'ready_for_signature'
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found or not ready for signature'));oute POST /api/documents/:id/send
    } */
res, next) => {
    if (!document.recipients || document.recipients.length === 0) {
      return next(new ApiError(400, 'Document has no recipients'));k if we're currently rate limited by Adobe Sign
    }if (rateLimitProtection.isRateLimited()) {
    
    // Validate recipient emailsLimitStatus();
    const invalidRecipients = document.recipients.filter(recipient => {
      const email = recipient.email;
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);ign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));
    });
    
    if (invalidRecipients.length > 0) {
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));ire('../config/adobeSign');
    }ateAdobeSignConfig();

    try {
      // Determine which file to use for Adobe Sign.error('Adobe Sign configuration validation failed:', configValidation.errors);
      let fileToUpload = document.filePath;0, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));
      
      // If document was processed from DOCX/DOC, use the PDF version
      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {onst document = await Document.findOne({
        fileToUpload = document.pdfFilePath;      _id: req.params.id,
        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);gnature'
      }
      
      // Check if file existsf (!document) {
      if (!fs.existsSync(fileToUpload)) {      return next(new ApiError(404, 'Document not found or not ready for signature'));
        logger.error(`File not found at path: ${fileToUpload}`);
        return next(new ApiError(404, 'Document file not found on server'));
      }cipients || document.recipients.length === 0) {
      recipients'));
      // Get file stats to ensure it's not empty
      const fileStats = fs.statSync(fileToUpload);
      if (fileStats.size === 0) {
        logger.error(`File is empty: ${fileToUpload}`);dRecipients = document.recipients.filter(recipient => {
        return next(new ApiError(400, 'Document file is empty')); = recipient.email;
      }]+\.[^\s@]+$/.test(email);
      
      // Upload as transient document
      logger.info(`Uploading document as transient document: ${document.originalName}`);if (invalidRecipients.length > 0) {
      const transientDocumentId = await uploadTransientDocument(fileToUpload);rror(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));
      logger.info(`Document uploaded as transient document: ${transientDocumentId}`);    }
      
      // Ensure we have a webhook setup for status updates
      try {termine which file to use for Adobe Sign
        // Get access token
        const accessToken = await getAccessToken();
         If document was processed from DOCX/DOC, use the PDF version
        // Setup webhook URL& fs.existsSync(document.pdfFilePath)) {
        const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;Path;
        le: ${document.pdfFilePath}`);
        // Check if webhook URL is HTTPS, which Adobe Sign requires
        const isHttps = webhookUrl.startsWith('https://');
        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1'); Check if file exists
        const isDevEnvironment = process.env.NODE_ENV === 'development';
        
        if (!isHttps && process.env.NODE_ENV === 'production') {return next(new ApiError(404, 'Document file not found on server'));
          logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);
        } 
        // Use mock implementation for development or non-HTTPS environments Get file stats to ensure it's not empty
        else if (webhookUrl) {nc(fileToUpload);
          try {
            // Import our improved webhook creator that handles non-HTTPS URLsempty: ${fileToUpload}`);
            const createWebhookLocal = require('../config/createWebhook');return next(new ApiError(400, 'Document file is empty'));
            const webhookResult = await createWebhookLocal(accessToken, webhookUrl);
            
            if (webhookResult._mockImplementation) {
              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);gger.info(`Uploading document as transient document: ${document.originalName}`);
            } else {
              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`);ment uploaded as transient document: ${transientDocumentId}`);
            }
          } catch (innerWebhookError) {tatus updates
            // Log the error but continue with document sendingry {
            logger.error(`Inner webhook error: ${innerWebhookError.message}`);   // Get access token
          }        const accessToken = await getAccessToken();
        } else {
          logger.warn('No webhook URL configured for Adobe Sign updates');
        }t('host')}/api/webhooks/adobe-sign`;
      } catch (webhookError) {    
        // Log the error but continue with document sendingbhook URL is HTTPS, which Adobe Sign requires
        logger.error(`Error setting up webhook: ${webhookError.message}`);//');
      } = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');
      Environment = process.env.NODE_ENV === 'development';
      // Use the comprehensive approach from adobeSignFormFields utility
      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);
      const result = await createAgreementWithBestApproach(       logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);
        transientDocumentId,      } 
        document.recipients,        // Use mock implementation for development or non-HTTPS environments
        document.originalName,     else if (webhookUrl) {
        {
          templateId: document.templateId, // If using templatestor that handles non-HTTPS URLs
          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],         const createWebhookLocal = require('../config/createWebhook');
          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)accessToken, webhookUrl);
        }     
      );plementation) {
                logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);
      // Update document with Adobe Sign agreement ID
      document.adobeAgreementId = result.agreementId;ign: ${webhookUrl}`);
      document.status = 'sent_for_signature';
      document.adobeMetadata = {
        agreementId: result.agreementId,       // Log the error but continue with document sending
        method: result.method,        logger.error(`Inner webhook error: ${innerWebhookError.message}`);
        createdAt: new Date()
      };
      
      // Special handling for rate limiting   }
      if (result.rateLimited) {  } catch (webhookError) {
        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);r but continue with document sending
        document.status = 'signature_error'; ${webhookError.message}`);
        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;  }
        document.adobeMetadata.rateLimited = true;
        document.adobeMetadata.retryAfter = result.retryAfter;
        document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));  logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);
        
        await document.save();    transientDocumentId,
        
        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));
      }
      eId, // If using templates
      // Update recipients statusDetectedSignatureFields: document.autoDetectedSignatureFields || [],
      document.recipients.forEach(recipient => {document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)
        recipient.status = 'sent';
      });
      
      await document.save();Sign agreement ID
      .adobeAgreementId = result.agreementId;
      // Log document sent for signatureor_signature';
      await Log.create({ {
        level: 'info',tId,
        message: `Document sent for signature using ${result.method} approach: ${document.originalName}`,
        
        documentId: document._id,
        ipAddress: req.ip,
        requestPath: req.originalUrl,Special handling for rate limiting
        requestMethod: req.method,lt.rateLimited) {
        metadata: {.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);
          adobeAgreementId: result.agreementId,
          method: result.method,   document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;
          recipientCount: document.recipients.length    document.adobeMetadata.rateLimited = true;
        }.retryAfter = result.retryAfter;
      });fter * 1000));
      
      logger.info(`Document sent for signature using ${result.method} approach: ${document.originalName} `);
      
      res.status(200).json(formatResponse(ached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));
        200,
        `Document sent for signature successfully using ${result.method} approach`,
        { pdate recipients status
          document,pient => {
          adobeAgreementId: result.agreementId,
          method: result.method
        }
      ));
    } catch (adobeError) {
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);for all recipients
      if (adobeError.response) {
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);sToken();
      }fo(accessToken, document.adobeAgreementId);
      
      // Update document status to indicate errornfo.participantSets) {
      document.status = 'signature_error'; participant sets and get their signing URLs
      document.errorMessage = adobeError.message;ecipients) {
      await document.save();ticipantSets) {
      rticipantSet.memberInfos) {
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`));) === recipient.email.toLowerCase()) {
    } try {
  } catch (error) { Get signing URL for this participant
    next(error); await getSigningUrl(
  }
};Id,
participant.participantId
/**
 * Get all documents for a user
 * @route GET /api/documents (signingUrlResponse.signingUrlSetInfos && 
 */gUrlResponse.signingUrlSetInfos[0] && 
exports.getDocuments = async (req, res, next) => {ningUrlSetInfos[0].signingUrls && 
  try {  signingUrlResponse.signingUrlSetInfos[0].signingUrls[0]) {
    const documents = await Document.find({})
      .sort({ createdAt: -1 });signingUrlResponse.signingUrlSetInfos[0].signingUrls[0].esignUrl;
    logger.info(`Stored signing URL for ${recipient.email}`);
    res.status(200).json(formatResponse(
      200,
      'Documents retrieved successfully',gger.error(`Error getting signing URL for ${recipient.email}: ${signingUrlError.message}`);
      { documents } Continue with other recipients even if one fails
    ));
  } catch (error) {k;
    next(error);   }
  }  }
};

/** 
 * Get a specific document   // Save the document with updated signing URLs
 * @route GET /api/documents/:id     await document.save();
 */    }
exports.getDocument = async (req, res, next) => {or) {
  try {r retrieving signing URLs: ${signingUrlError.message}`);
    const document = await Document.findOne({     // Continue anyway - signing URLs can be retrieved later if needed
      _id: req.params.id
    });
    
    if (!document) {ait Log.create({
      return next(new ApiError(404, 'Document not found'));o',
    }using ${result.method} approach: ${document.originalName}`,
    
    res.status(200).json(formatResponse(     ipAddress: req.ip,
      200,      requestPath: req.originalUrl,
      'Document retrieved successfully',        requestMethod: req.method,
      { document }     metadata: {
    ));d,
  } catch (error) {
    next(error);       recipientCount: document.recipients.length,
  }          combined_operation: true





















































































































































































































































































































































































































































































































































































      document.re      // Update recipients status            }        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));                await document.save();                document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));        document.adobeMetadata.retryAfter = result.retryAfter;        document.adobeMetadata.rateLimited = true;        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;        document.status = 'signature_error';        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);      if (result.rateLimited) {      // Special handling for rate limiting            };        createdAt: new Date()        method: result.method,        agreementId: result.agreementId,      document.adobeMetadata = {      document.status = 'sent_for_signature';      document.adobeAgreementId = result.agreementId;      // Update document with Adobe Sign agreement ID            );        }          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],          templateId: document.templateId, // If using templates        {        document.originalName,        document.recipients,        transientDocumentId,      const result = await createAgreementWithBestApproach(      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);      // Use the comprehensive approach from adobeSignFormFields utility            }        logger.error(`Error setting up webhook: ${webhookError.message}`);        // Log the error but continue with document sending      } catch (webhookError) {        }          logger.warn('No webhook URL configured for Adobe Sign updates');        } else {          }            logger.error(`Inner webhook error: ${innerWebhookError.message}`);            // Log the error but continue with document sending          } catch (innerWebhookError) {            }              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`);            } else {              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);            if (webhookResult._mockImplementation) {                        const webhookResult = await createWebhookLocal(accessToken, webhookUrl);            const createWebhookLocal = require('../config/createWebhook');            // Import our improved webhook creator that handles non-HTTPS URLs          try {        else if (webhookUrl) {        // Use mock implementation for development or non-HTTPS environments        }           logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);        if (!isHttps && process.env.NODE_ENV === 'production') {                const isDevEnvironment = process.env.NODE_ENV === 'development';        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');        const isHttps = webhookUrl.startsWith('https://');        // Check if webhook URL is HTTPS, which Adobe Sign requires                const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;        // Setup webhook URL                const accessToken = await getAccessToken();        // Get access token      try {      // Ensure we have a webhook setup for status updates            logger.info(`Document uploaded as transient document: ${transientDocumentId}`);      const transientDocumentId = await uploadTransientDocument(fileToUpload);      logger.info(`Uploading document as transient document: ${document.originalName}`);      // Upload as transient document            }        return next(new ApiError(400, 'Document file is empty'));        logger.error(`File is empty: ${fileToUpload}`);      if (fileStats.size === 0) {      const fileStats = fs.statSync(fileToUpload);      // Get file stats to ensure it's not empty            }        return next(new ApiError(404, 'Document file not found on server'));        logger.error(`File not found at path: ${fileToUpload}`);      if (!fs.existsSync(fileToUpload)) {      // Check if file exists            }        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);        fileToUpload = document.pdfFilePath;      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {      // If document was processed from DOCX/DOC, use the PDF version            let fileToUpload = document.filePath;      // Determine which file to use for Adobe Sign    try {    }      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));    if (invalidRecipients.length > 0) {        });      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);      const email = recipient.email;    const invalidRecipients = document.recipients.filter(recipient => {    // Validate recipient emails        }      return next(new ApiError(400, 'Document has no recipients'));    if (!document.recipients || document.recipients.length === 0) {    }      return next(new ApiError(404, 'Document not found or not ready for signature'));    if (!document) {        });      status: 'ready_for_signature'      _id: req.params.id,    const document = await Document.findOne({        }      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);    if (!configValidation.isValid) {        const configValidation = validateAdobeSignConfig();    const { validateAdobeSignConfig } = require('../config/adobeSign');    // First validate Adobe Sign configuration        }      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));      logger.warn(`Rate limit check failed: ${status}`);            const status = rateLimitProtection.getRateLimitStatus();      const timeRemaining = rateLimitProtection.getTimeRemaining();    if (rateLimitProtection.isRateLimited()) {    // First check if we're currently rate limited by Adobe Sign    // Step 3: Send document for signature using the best approach        logger.info(`Document prepared for signature: ${document.originalName}`);        });      }        recipientCount: recipients.length      metadata: {      requestMethod: req.method,      requestPath: req.originalUrl,      ipAddress: req.ip,      documentId: document._id,      message: `Document prepared for signature: ${document.originalName}`,      level: 'info',    await Log.create({    // Log document preparation        await document.save();    document.signingFlow = selectedSigningFlow;    document.signatureFieldMapping = signatureFieldMapping || {};    document.status = 'ready_for_signature';    document.recipients = formattedRecipients;    // Update document with recipients and signature field mapping        });      };        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`        status: 'pending',        order: index + 1,        email: recipient.email,        name: recipient.name,      return {            }        throw new ApiError(400, 'Each recipient must have a name and email');      if (!recipient.name || !recipient.email) {    const formattedRecipients = recipients.map((recipient, index) => {    // Validate and format recipients          : 'SEQUENTIAL'; // Default to sequential (updated default)      ? signingFlow.toUpperCase()     const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase())     const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];    // Validate signing flow option        }      return next(new ApiError(400, 'Recipients must be an array'));    } else if (!Array.isArray(recipients)) {      }        return next(new ApiError(400, 'Recipients are required either in request body or template data'));      } else {        }          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);          });            }              signatureFieldMapping[recipient.email] = recipient.signatureField;            if (recipient.signatureField) {          recipients.forEach(recipient => {          signatureFieldMapping = {};        if (!signatureFieldMapping) {        // Auto-generate signature field mapping from extracted recipients                logger.info(`Extracted ${recipients.length} recipients from template data`);        }          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));        if (!recipients || recipients.length === 0) {                recipients = extractRecipientsFromTemplateData(document.templateData);        logger.info('No recipients provided, extracting from template data');      if (document.templateData) {    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {    // If no recipients provided, try to extract from JSON template data    }      return next(new ApiError(404, 'Document not found'));    if (!document) {        });      _id: req.params.id    const document = await Document.findOne({        let { recipients, signatureFieldMapping, signingFlow } = req.body;  try {exports.prepareForSignature = async (req, res, next) => { */ * @route POST /api/documents/:id/prepare * Prepare document for e-signature/**};  }    next(error);  } catch (error) {    ));      { document }      'Document retrieved successfully',      200,    res.status(200).json(formatResponse(        }      return next(new ApiError(404, 'Document not found'));    if (!document) {        });      _id: req.params.id    const document = await Document.findOne({   try {exports.getDocument = async (req, res, next) => { */ * @route GET /api/documents/:id * Get a specific document/**};  }    next(error);  } catch (error) {    ));      { documents }      'Documents retrieved successfully',      200,    res.status(200).json(formatResponse(          .sort({ createdAt: -1 });    const documents = await Document.find({})  try {exports.getDocuments = async (req, res, next) => { */ * @route GET /api/documents * Get all documents for a user/**};  }    next(error);  } catch (error) {    }      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`));            await document.save();      document.errorMessage = adobeError.message;      document.status = 'signature_error';      // Update document status to indicate error            }        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);      if (adobeError.response) {      logger.error(`Adobe Sign API Error: ${adobeError.message}`);    } catch (adobeError) {      ));        }          method: result.method          adobeAgreementId: result.agreementId,          document,        {         `Document sent for signature successfully using ${result.method} approach`,        200,      res.status(200).json(formatResponse(            logger.info(`Document sent for signature using ${result.method} approach: ${document.originalName} `);            });        }          recipientCount: document.recipients.length          method: result.method,          adobeAgreementId: result.agreementId,        metadata: {        requestMethod: req.method,        requestPath: req.originalUrl,        ipAddress: req.ip,        documentId: document._id,                message: `Document sent for signature using ${result.method} approach: ${document.originalName}`,        level: 'info',      await Log.create({      // Log document sent for signature            await document.save();            });        recipient.status = 'sent';      document.recipients.forEach(recipient => {      // Update recipients status            }        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));                await document.save();                document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));        document.adobeMetadata.retryAfter = result.retryAfter;        document.adobeMetadata.rateLimited = true;        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;        document.status = 'signature_error';        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);      if (result.rateLimited) {      // Special handling for rate limiting            };        createdAt: new Date()        method: result.method,        agreementId: result.agreementId,      document.adobeMetadata = {      document.status = 'sent_for_signature';      document.adobeAgreementId = result.agreementId;      // Update document with Adobe Sign agreement ID            );        }          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],          templateId: document.templateId, // If using templates        {        document.originalName,        document.recipients,        transientDocumentId,      const result = await createAgreementWithBestApproach(      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);      // Use the comprehensive approach from adobeSignFormFields utility            }        logger.error(`Error setting up webhook: ${webhookError.message}`);        // Log the error but continue with document sending      } catch (webhookError) {        }          logger.warn('No webhook URL configured for Adobe Sign updates');        } else {          }            logger.error(`Inner webhook error: ${innerWebhookError.message}`);            // Log the error but continue with document sending          } catch (innerWebhookError) {            }              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`);            } else {              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);            if (webhookResult._mockImplementation) {                        const webhookResult = await createWebhookLocal(accessToken, webhookUrl);            const createWebhookLocal = require('../config/createWebhook');            // Import our improved webhook creator that handles non-HTTPS URLs          try {        else if (webhookUrl) {        // Use mock implementation for development or non-HTTPS environments        }           logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);        if (!isHttps && process.env.NODE_ENV === 'production') {                const isDevEnvironment = process.env.NODE_ENV === 'development';        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');        const isHttps = webhookUrl.startsWith('https://');        // Check if webhook URL is HTTPS, which Adobe Sign requires                const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;        // Setup webhook URL                const accessToken = await getAccessToken();        // Get access token      try {      // Ensure we have a webhook setup for status updates            logger.info(`Document uploaded as transient document: ${transientDocumentId}`);      const transientDocumentId = await uploadTransientDocument(fileToUpload);      logger.info(`Uploading document as transient document: ${document.originalName}`);      // Upload as transient document            }        return next(new ApiError(400, 'Document file is empty'));        logger.error(`File is empty: ${fileToUpload}`);      if (fileStats.size === 0) {      const fileStats = fs.statSync(fileToUpload);      // Get file stats to ensure it's not empty            }        return next(new ApiError(404, 'Document file not found on server'));        logger.error(`File not found at path: ${fileToUpload}`);      if (!fs.existsSync(fileToUpload)) {      // Check if file exists            }        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);        fileToUpload = document.pdfFilePath;      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {      // If document was processed from DOCX/DOC, use the PDF version            let fileToUpload = document.filePath;      // Determine which file to use for Adobe Sign    try {    }      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));    if (invalidRecipients.length > 0) {        });      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);      const email = recipient.email;    const invalidRecipients = document.recipients.filter(recipient => {    // Validate recipient emails        }      return next(new ApiError(400, 'Document has no recipients'));    if (!document.recipients || document.recipients.length === 0) {    }      return next(new ApiError(404, 'Document not found or not ready for signature'));    if (!document) {        });      status: 'ready_for_signature'      _id: req.params.id,    const document = await Document.findOne({        }      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);    if (!configValidation.isValid) {        const configValidation = validateAdobeSignConfig();    const { validateAdobeSignConfig } = require('../config/adobeSign');    // First validate Adobe Sign configuration        }      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));      logger.warn(`Rate limit check failed: ${status}`);            const status = rateLimitProtection.getRateLimitStatus();      const timeRemaining = rateLimitProtection.getTimeRemaining();    if (rateLimitProtection.isRateLimited()) {    // First check if we're currently rate limited by Adobe Sign    // Step 3: Send document for signature using the best approach        logger.info(`Document prepared for signature: ${document.originalName}`);        });      }        recipientCount: recipients.length      metadata: {      requestMethod: req.method,      requestPath: req.originalUrl,      ipAddress: req.ip,      documentId: document._id,      message: `Document prepared for signature: ${document.originalName}`,      level: 'info',    await Log.create({    // Log document preparation        await document.save();    document.signingFlow = selectedSigningFlow;    document.signatureFieldMapping = signatureFieldMapping || {};    document.status = 'ready_for_signature';    document.recipients = formattedRecipients;    // Update document with recipients and signature field mapping        });      };        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`        status: 'pending',        order: index + 1,        email: recipient.email,        name: recipient.name,      return {            }        throw new ApiError(400, 'Each recipient must have a name and email');      if (!recipient.name || !recipient.email) {    const formattedRecipients = recipients.map((recipient, index) => {    // Validate and format recipients          : 'SEQUENTIAL'; // Default to sequential (updated default)      ? signingFlow.toUpperCase()     const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase())     const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];    // Validate signing flow option        }      return next(new ApiError(400, 'Recipients must be an array'));    } else if (!Array.isArray(recipients)) {      }        return next(new ApiError(400, 'Recipients are required either in request body or template data'));      } else {        }          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);          });            }              signatureFieldMapping[recipient.email] = recipient.signatureField;            if (recipient.signatureField) {          recipients.forEach(recipient => {          signatureFieldMapping = {};        if (!signatureFieldMapping) {        // Auto-generate signature field mapping from extracted recipients                logger.info(`Extracted ${recipients.length} recipients from template data`);        }          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));        if (!recipients || recipients.length === 0) {                recipients = extractRecipientsFromTemplateData(document.templateData);        logger.info('No recipients provided, extracting from template data');      if (document.templateData) {    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {    // If no recipients provided, try to extract from JSON template data    }      return next(new ApiError(404, 'Document not found'));    if (!document) {        });      _id: req.params.id    const document = await Document.findOne({        let { recipients, signatureFieldMapping, signingFlow } = req.body;  try {exports.prepareForSignature = async (req, res, next) => { */ * @route POST /api/documents/:id/prepare * Prepare document for e-signature/**};        }
      });
      
      logger.info(`Document uploaded, prepared, and sent for signature using ${result.method} approach: ${document.originalName}`);
      
      res.status(201).json(formatResponse(
        201,
        `Document uploaded, prepared, and sent for signature successfully using ${result.method} approach`,
        { 
          document,
          adobeAgreementId: result.agreementId,
          method: result.method,
          signingUrls: document.recipients.map(r => ({
            email: r.email,
            signingUrl: r.signingUrl
          })).filter(r => r.signingUrl)
        }
      ));
    } catch (adobeError) {
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);
      if (adobeError.response) {
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);
      }
      
      // Update document status to indicate error
      document.status = 'signature_error';
      document.errorMessage = adobeError.message;
      await document.save();
      
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`));
    }
  } catch (error) {
    next(error);
  }
};

/**
 * Get all documents for a user
 * @route GET /api/documents
 */
exports.getDocuments = async (req, res, next) => {
  try {
    const documents = await Document.find({})
      .sort({ createdAt: -1 });
    
    res.status(200).json(formatResponse(
      200,
      'Documents retrieved successfully',
      { documents }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Get a specific document
 * @route GET /api/documents/:id
 */
exports.getDocument = async (req, res, next) => {
  try {
    const document = await Document.findOne({ 
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }
    
    res.status(200).json(formatResponse(
      200,
      'Document retrieved successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Prepare document for e-signature
 * @route POST /api/documents/:id/prepare
 */
exports.prepareForSignature = async (req, res, next) => {
  try {
    let { recipients, signatureFieldMapping, signingFlow } = req.body;
    
    const document = await Document.findOne({
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }

    // If no recipients provided, try to extract from JSON template data
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {
      if (document.templateData) {
        logger.info('No recipients provided, extracting from template data');
        recipients = extractRecipientsFromTemplateData(document.templateData);
        
        if (!recipients || recipients.length === 0) {
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));
        }
        logger.info(`Extracted ${recipients.length} recipients from template data`);
        
        // Auto-generate signature field mapping from extracted recipients
        if (!signatureFieldMapping) {
          signatureFieldMapping = {};
          recipients.forEach(recipient => {
            if (recipient.signatureField) {
              signatureFieldMapping[recipient.email] = recipient.signatureField;
            }
          });
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);
        }
      } else {
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));
      }
    } else if (!Array.isArray(recipients)) {
      return next(new ApiError(400, 'Recipients must be an array'));
    }
    
    // Validate signing flow option
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) 
      ? signingFlow.toUpperCase() 
      : 'SEQUENTIAL'; // Default to sequential (updated default)
    
    // Validate and format recipients
    const formattedRecipients = recipients.map((recipient, index) => {
      if (!recipient.name || !recipient.email) {
        throw new ApiError(400, 'Each recipient must have a name and email');
      }
      
      return {
        name: recipient.name,
        email: recipient.email,
        order: index + 1,
        status: 'pending',
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`
      };
    });
    
    // Update document with recipients and signature field mapping
    document.recipients = formattedRecipients;
    document.status = 'ready_for_signature';
    document.signatureFieldMapping = signatureFieldMapping || {};
    document.signingFlow = selectedSigningFlow;
    await document.save();
    
    // Log document preparation
    await Log.create({
      level: 'info',
      message: `Document prepared for signature: ${document.originalName}`,
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,
      requestMethod: req.method,
      metadata: {
        recipientCount: recipients.length
      }
    });
    
    logger.info(`Document prepared for signature: ${document.originalName}`);
    
    res.status(200).json(formatResponse(
      200,
      'Document prepared for signature successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Send document for e-signature using the best approach
 * @route POST /api/documents/:id/send
 */
exports.sendForSignature = async (req, res, next) => {
  try {
    // First check if we're currently rate limited by Adobe Sign
    if (rateLimitProtection.isRateLimited()) {
      const timeRemaining = rateLimitProtection.getTimeRemaining();
      const status = rateLimitProtection.getRateLimitStatus();
      
      logger.warn(`Rate limit check failed: ${status}`);
      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));
    }
    
    // First validate Adobe Sign configuration
    const { validateAdobeSignConfig } = require('../config/adobeSign');
    const configValidation = validateAdobeSignConfig();
    
    if (!configValidation.isValid) {
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));
    }
    
    const document = await Document.findOne({
      _id: req.params.id,
      status: 'ready_for_signature'
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found or not ready for signature'));
    }

    if (!document.recipients || document.recipients.length === 0) {
      return next(new ApiError(400, 'Document has no recipients'));
    }
    
    // Validate recipient emails
    const invalidRecipients = document.recipients.filter(recipient => {
      const email = recipient.email;
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    });
    
    if (invalidRecipients.length > 0) {
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));
    }

    try {
      // Determine which file to use for Adobe Sign
      let fileToUpload = document.filePath;
      
      // If document was processed from DOCX/DOC, use the PDF version
      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {
        fileToUpload = document.pdfFilePath;
        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);
      }
      
      // Check if file exists
      if (!fs.existsSync(fileToUpload)) {
        logger.error(`File not found at path: ${fileToUpload}`);
        return next(new ApiError(404, 'Document file not found on server'));
      }
      
      // Get file stats to ensure it's not empty
      const fileStats = fs.statSync(fileToUpload);
      if (fileStats.size === 0) {
        logger.error(`File is empty: ${fileToUpload}`);
        return next(new ApiError(400, 'Document file is empty'));
      }
      
      // Upload as transient document
      logger.info(`Uploading document as transient document: ${document.originalName}`);
      const transientDocumentId = await uploadTransientDocument(fileToUpload);
      logger.info(`Document uploaded as transient document: ${transientDocumentId}`);
      
      // Ensure we have a webhook setup for status updates
      try {
        // Get access token
        const accessToken = await getAccessToken();
        
        // Setup webhook URL
        const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;
        
        // Check if webhook URL is HTTPS, which Adobe Sign requires
        const isHttps = webhookUrl.startsWith('https://');
        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');
        const isDevEnvironment = process.env.NODE_ENV === 'development';
        
        if (!isHttps && process.env.NODE_ENV === 'production') {
          logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);
        } 
        // Use mock implementation for development or non-HTTPS environments
        else if (webhookUrl) {
          try {
            // Import our improved webhook creator that handles non-HTTPS URLs
            const createWebhookLocal = require('../config/createWebhook');
            const webhookResult = await createWebhookLocal(accessToken, webhookUrl);
            
            if (webhookResult._mockImplementation) {
              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);
            } else {
              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`);
            }
          } catch (innerWebhookError) {
            // Log the error but continue with document sending
            logger.error(`Inner webhook error: ${innerWebhookError.message}`);
          }
        } else {
          logger.warn('No webhook URL configured for Adobe Sign updates');
        }
      } catch (webhookError) {
        // Log the error but continue with document sending
        logger.error(`Error setting up webhook: ${webhookError.message}`);
      }
      
      // Use the comprehensive approach from adobeSignFormFields utility
      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);
      const result = await createAgreementWithBestApproach(
        transientDocumentId,
        document.recipients,
        document.originalName,
        {
          templateId: document.templateId, // If using templates
          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],
          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)
        }
      );
      
      // Update document with Adobe Sign agreement ID
      document.adobeAgreementId = result.agreementId;
      document.status = 'sent_for_signature';
      document.adobeMetadata = {
        agreementId: result.agreementId,
        method: result.method,
        createdAt: new Date()
      };
      
      // Special handling for rate limiting
      if (result.rateLimited) {
        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);
        document.status = 'signature_error';
        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;
        document.adobeMetadata.rateLimited = true;
        document.adobeMetadata.retryAfter = result.retryAfter;
        document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));
        
        await document.save();
        
        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));
      }
      
      // Update recipients status
      document.recipients.forEach(recipient => {
        recipient.status = 'sent';
      });
      
      await document.save();
      
      // Step 4: Get and store signing URLs for all recipients
      try {
        const accessToken = await getAccessToken();
        const agreementInfo = await getAgreementInfo(accessToken, document.adobeAgreementId);
        
        if (agreementInfo.participantSets) {
          // Map recipients to participant sets and get their signing URLs
          for (const recipient of document.recipients) {
            for (const participantSet of agreementInfo.participantSets) {
              for (const participant of participantSet.memberInfos) {
                if (participant.email.toLowerCase() === recipient.email.toLowerCase()) {
                  try {
                    // Get signing URL for this participant
                    const signingUrlResponse = await getSigningUrl(
                      accessToken, 
                      document.adobeAgreementId,
                      participant.participantId
                    );
                    
                    if (signingUrlResponse.signingUrlSetInfos && 
                        signingUrlResponse.signingUrlSetInfos[0] && 
                        signingUrlResponse.signingUrlSetInfos[0].signingUrls && 
                        signingUrlResponse.signingUrlSetInfos[0].signingUrls[0]) {
                      
                      recipient.signingUrl = signingUrlResponse.signingUrlSetInfos[0].signingUrls[0].esignUrl;
                      logger.info(`Stored signing URL for ${recipient.email}`);
                    }
                  } catch (signingUrlError) {
                    logger.error(`Error getting signing URL for ${recipient.email}: ${signingUrlError.message}`);
                    // Continue with other recipients even if one fails
                  }
                  break;
                }
              }
            }
          }
          
          // Save the document with updated signing URLs
          await document.save();
        }
      } catch (signingUrlError) {
        logger.error(`Error retrieving signing URLs: ${signingUrlError.message}`);
        // Continue anyway - signing URLs can be retrieved later if needed
      }
      
      // Log document sent for signature
      await Log.create({
        level: 'info',
        message: `Document uploaded, prepared, and sent for signature using ${result.method} approach: ${document.originalName}`,
        documentId: document._id,
        ipAddress: req.ip,
        requestPath: req.originalUrl,
        requestMethod: req.method,
        metadata: {
          adobeAgreementId: result.agreementId,
          method: result.method,
          recipientCount: document.recipients.length,
          combined_operation: true
        }
      });
      
      logger.info(`Document uploaded, prepared, and sent for signature using ${result.method} approach: ${document.originalName}`);
      
      res.status(201).json(formatResponse(
        201,
        `Document uploaded, prepared, and sent for signature successfully using ${result.method} approach`,
        { 
          document,
          adobeAgreementId: result.agreementId,
          method: result.method,
          signingUrls: document.recipients.map(r => ({
            email: r.email,
            signingUrl: r.signingUrl
          })).filter(r => r.signingUrl)
        }
      ));
    } catch (adobeError) {
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);
      if (adobeError.response) {
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);
      }
      
      // Update document status to indicate error
      document.status = 'signature_error';
      document.errorMessage = adobeError.message;
      await document.save();
      
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`));
    }
  } catch (error) {
    next(error);
  }
};

/**
 * Get all documents for a user
 * @route GET /api/documents
 */
exports.getDocuments = async (req, res, next) => {
  try {
    const documents = await Document.find({})
      .sort({ createdAt: -1 });
    
    res.status(200).json(formatResponse(
      200,
      'Documents retrieved successfully',
      { documents }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Get a specific document
 * @route GET /api/documents/:id
 */
exports.getDocument = async (req, res, next) => {
  try {
    const document = await Document.findOne({ 
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }
    
    res.status(200).json(formatResponse(
      200,
      'Document retrieved successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Prepare document for e-signature
 * @route POST /api/documents/:id/prepare
 */
exports.prepareForSignature = async (req, res, next) => {
  try {
    let { recipients, signatureFieldMapping, signingFlow } = req.body;
    
    const document = await Document.findOne({
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }

    // If no recipients provided, try to extract from JSON template data
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {
      if (document.templateData) {
        logger.info('No recipients provided, extracting from template data');
        recipients = extractRecipientsFromTemplateData(document.templateData);
        
        if (!recipients || recipients.length === 0) {
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));
        }
        logger.info(`Extracted ${recipients.length} recipients from template data`);
        
        // Auto-generate signature field mapping from extracted recipients
        if (!signatureFieldMapping) {
          signatureFieldMapping = {};
          recipients.forEach(recipient => {
            if (recipient.signatureField) {
              signatureFieldMapping[recipient.email] = recipient.signatureField;
            }
          });
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);
        }
      } else {
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));
      }
    } else if (!Array.isArray(recipients)) {
      return next(new ApiError(400, 'Recipients must be an array'));
    }
    
    // Validate signing flow option
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) 
      ? signingFlow.toUpperCase() 
      : 'SEQUENTIAL'; // Default to sequential (updated default)
    
    // Validate and format recipients
    const formattedRecipients = recipients.map((recipient, index) => {
      if (!recipient.name || !recipient.email) {
        throw new ApiError(400, 'Each recipient must have a name and email');
      }
      
      return {
        name: recipient.name,
        email: recipient.email,
        order: index + 1,
        status: 'pending',
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`
      };
    });
    
    // Update document with recipients and signature field mapping
    document.recipients = formattedRecipients;
    document.status = 'ready_for_signature';
    document.signatureFieldMapping = signatureFieldMapping || {};
    document.signingFlow = selectedSigningFlow;
    await document.save();
    
    // Log document preparation
    await Log.create({
      level: 'info',
      message: `Document prepared for signature: ${document.originalName}`,
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,
      requestMethod: req.method,
      metadata: {
        recipientCount: recipients.length
      }
    });
    
    logger.info(`Document prepared for signature: ${document.originalName}`);
    
    res.status(200).json(formatResponse(
      200,
      'Document prepared for signature successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Send document for e-signature using the best approach
 * @route POST /api/documents/:id/send
 */
exports.sendForSignature = async (req, res, next) => {
  try {
    // First check if we're currently rate limited by Adobe Sign
    if (rateLimitProtection.isRateLimited()) {
      const timeRemaining = rateLimitProtection.getTimeRemaining();
      const status = rateLimitProtection.getRateLimitStatus();
      
      logger.warn(`Rate limit check failed: ${status}`);
      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));
    }
    
    // First validate Adobe Sign configuration
    const { validateAdobeSignConfig } = require('../config/adobeSign');
    const configValidation = validateAdobeSignConfig();
    
    if (!configValidation.isValid) {
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));
    }
    
    const document = await Document.findOne({
      _id: req.params.id,
      status: 'ready_for_signature'
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found or not ready for signature'));
    }

    if (!document.recipients || document.recipients.length === 0) {
      return next(new ApiError(400, 'Document has no recipients'));
    }
    
    // Validate recipient emails
    const invalidRecipients = document.recipients.filter(recipient => {
      const email = recipient.email;
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    });
    
    if (invalidRecipients.length > 0) {
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));
    }

    try {
      // Determine which file to use for Adobe Sign
      let fileToUpload = document.filePath;
      
      // If document was processed from DOCX/DOC, use the PDF version
      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {
        fileToUpload = document.pdfFilePath;
        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);
      }
      
      // Check if file exists
      if (!fs.existsSync(fileToUpload)) {
        logger.error(`File not found at path: ${fileToUpload}`);
        return next(new ApiError(404, 'Document file not found on server'));
      }
      
      // Get file stats to ensure it's not empty
      const fileStats = fs.statSync(fileToUpload);
      if (fileStats.size === 0) {
        logger.error(`File is empty: ${fileToUpload}`);
        return next(new ApiError(400, 'Document file is empty'));
      }
      
      // Upload as transient document
      logger.info(`Uploading document as transient document: ${document.originalName}`);
      const transientDocumentId = await uploadTransientDocument(fileToUpload);
      logger.info(`Document uploaded as transient document: ${transientDocumentId}`);
      
      // Ensure we have a webhook setup for status updates
      try {
        // Get access token
        const accessToken = await getAccessToken();
        
        // Setup webhook URL
        const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;
        
        // Check if webhook URL is HTTPS, which Adobe Sign requires
        const isHttps = webhookUrl.startsWith('https://');
        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');
        const isDevEnvironment = process.env.NODE_ENV === 'development';
        
        if (!isHttps && process.env.NODE_ENV === 'production') {
          logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);
        } 
        // Use mock implementation for development or non-HTTPS environments
        else if (webhookUrl) {
          try {
            // Import our improved webhook creator that handles non-HTTPS URLs
            const createWebhookLocal = require('../config/createWebhook');
            const webhookResult = await createWebhookLocal(accessToken, webhookUrl);
            
            if (webhookResult._mockImplementation) {
              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);
            } else {
              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`);
            }
          } catch (innerWebhookError) {
            // Log the error but continue with document sending
            logger.error(`Inner webhook error: ${innerWebhookError.message}`);
          }
        } else {
          logger.warn('No webhook URL configured for Adobe Sign updates');
        }
      } catch (webhookError) {
        // Log the error but continue with document sending
        logger.error(`Error setting up webhook: ${webhookError.message}`);
      }
      
      // Use the comprehensive approach from adobeSignFormFields utility
      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);
      const result = await createAgreementWithBestApproach(
        transientDocumentId,
        document.recipients,
        document.originalName,
        {
          templateId: document.templateId, // If using templates
          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],
          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)
        }
      );
      
      // Update document with Adobe Sign agreement ID
      document.adobeAgreementId = result.agreementId;
      document.status = 'sent_for_signature';
      document.adobeMetadata = {
        agreementId: result.agreementId,
        method: result.method,
        createdAt: new Date()
      };
      
      // Special handling for rate limiting
      if (result.rateLimited) {
        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);
        document.status = 'signature_error';
        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;
        document.adobeMetadata.rateLimited = true;
        document.adobeMetadata.retryAfter = result.retryAfter;
        document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));
        
        await document.save();
        
        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));
      }
      
      // Update recipients status
      document.recipients.forEach(recipient => {
        recipient.status = 'sent';
      });
      
      await document.save();
      
      // Step 4: Get and store signing URLs for all recipients
      try {
        const accessToken = await getAccessToken();
        const agreementInfo = await getAgreementInfo(accessToken, document.adobeAgreementId);
        
        if (agreementInfo.participantSets) {
          // Map recipients to participant sets and get their signing URLs
          for (const recipient of document.recipients) {
            for (const participantSet of agreementInfo.participantSets) {
              for (const participant of participantSet.memberInfos) {
                if (participant.email.toLowerCase() === recipient.email.toLowerCase()) {
                  try {
                    // Get signing URL for this participant
                    const signingUrlResponse = await getSigningUrl(
                      accessToken, 
                      document.adobeAgreementId,
                      participant.participantId
                    );
                    
                    if (signingUrlResponse.signingUrlSetInfos && 
                        signingUrlResponse.signingUrlSetInfos[0] && 
                        signingUrlResponse.signingUrlSetInfos[0].signingUrls && 
                        signingUrlResponse.signingUrlSetInfos[0].signingUrls[0]) {
                      
                      recipient.signingUrl = signingUrlResponse.signingUrlSetInfos[0].signingUrls[0].esignUrl;
                      logger.info(`Stored signing URL for ${recipient.email}`);
                    }
                  } catch (signingUrlError) {
                    logger.error(`Error getting signing URL for ${recipient.email}: ${signingUrlError.message}`);
                    // Continue with other recipients even if one fails
                  }
                  break;
                }
              }
            }
          }
          
          // Save the document with updated signing URLs
          await document.save();
        }
      } catch (signingUrlError) {
        logger.error(`Error retrieving signing URLs: ${signingUrlError.message}`);
        // Continue anyway - signing URLs can be retrieved later if needed
      }
      
      // Log document sent for signature
      await Log.create({
        level: 'info',
        message: `Document uploaded, prepared, and sent for signature using ${result.method} approach: ${document.originalName}`,
        documentId: document._id,
        ipAddress: req.ip,
        requestPath: req.originalUrl,
        requestMethod: req.method,
        metadata: {
          adobeAgreementId: result.agreementId,
          method: result.method,
          recipientCount: document.recipients.length,
          combined_operation: true
        }
      });
      
      logger.info(`Document uploaded, prepared, and sent for signature using ${result.method} approach: ${document.originalName}`);
      
      res.status(201).json(formatResponse(
        201,
        `Document uploaded, prepared, and sent for signature successfully using ${result.method} approach`,
        { 
          document,
          adobeAgreementId: result.agreementId,
          method: result.method,
          signingUrls: document.recipients.map(r => ({
            email: r.email,
            signingUrl: r.signingUrl
          })).filter(r => r.signingUrl)
        }
      ));
    } catch (adobeError) {
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);
      if (adobeError.response) {
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);
      }
      
      // Update document status to indicate error
      document.status = 'signature_error';
      document.errorMessage = adobeError.message;
      await document.save();
      
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`));
    }
  } catch (error) {
    next(error);
  }
};

/**
 * Get all documents for a user
 * @route GET /api/documents
 */
exports.getDocuments = async (req, res, next) => {
  try {
    const documents = await Document.find({})
      .sort({ createdAt: -1 });
    
    res.status(200).json(formatResponse(
      200,
      'Documents retrieved successfully',
      { documents }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Get a specific document
 * @route GET /api/documents/:id
 */
exports.getDocument = async (req, res, next) => {
  try {
    const document = await Document.findOne({ 
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }
    
    res.status(200).json(formatResponse(
      200,
      'Document retrieved successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Prepare document for e-signature
 * @route POST /api/documents/:id/prepare
 */
exports.prepareForSignature = async (req, res, next) => {
  try {
    let { recipients, signatureFieldMapping, signingFlow } = req.body;
    
    const document = await Document.findOne({
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }

    // If no recipients provided, try to extract from JSON template data
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {
      if (document.templateData) {
        logger.info('No recipients provided, extracting from template data');
        recipients = extractRecipientsFromTemplateData(document.templateData);
        
        if (!recipients || recipients.length === 0) {
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));
        }
        logger.info(`Extracted ${recipients.length} recipients from template data`);
        
        // Auto-generate signature field mapping from extracted recipients
        if (!signatureFieldMapping) {
          signatureFieldMapping = {};
          recipients.forEach(recipient => {
            if (recipient.signatureField) {
              signatureFieldMapping[recipient.email] = recipient.signatureField;
            }
          });
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);
        }
      } else {
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));
      }
    } else if (!Array.isArray(recipients)) {
      return next(new ApiError(400, 'Recipients must be an array'));
    }
    
    // Validate signing flow option
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) 
      ? signingFlow.toUpperCase() 
      : 'SEQUENTIAL'; // Default to sequential (updated default)
    
    // Validate and format recipients
    const formattedRecipients = recipients.map((recipient, index) => {
      if (!recipient.name || !recipient.email) {
        throw new ApiError(400, 'Each recipient must have a name and email');
      }
      
      return {
        name: recipient.name,
        email: recipient.email,
        order: index + 1,
        status: 'pending',
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`
      };
    });
    
    // Update document with recipients and signature field mapping
    document.recipients = formattedRecipients;
    document.status = 'ready_for_signature';
    document.signatureFieldMapping = signatureFieldMapping || {};
    document.signingFlow = selectedSigningFlow;
    await document.save();
    
    // Log document preparation
    await Log.create({
      level: 'info',
      message: `Document prepared for signature: ${document.originalName}`,
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,
      requestMethod: req.method,
      metadata: {
        recipientCount: recipients.length
      }
    });
    
    logger.info(`Document prepared for signature: ${document.originalName}`);
    
    res.status(200).json(formatResponse(
      200,
      'Document prepared for signature successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Send document for e-signature using the best approach
 * @route POST /api/documents/:id/send
 */
exports.sendForSignature = async (req, res, next) => {
  try {
    // First check if we're currently rate limited by Adobe Sign
    if (rateLimitProtection.isRateLimited()) {
      const timeRemaining = rateLimitProtection.getTimeRemaining();
      const status = rateLimitProtection.getRateLimitStatus();
      
      logger.warn(`Rate limit check failed: ${status}`);
      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));
    }
    
    // First validate Adobe Sign configuration
    const { validateAdobeSignConfig } = require('../config/adobeSign');
    const configValidation = validateAdobeSignConfig();
    
    if (!configValidation.isValid) {
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));
    }
    
    const document = await Document.findOne({
      _id: req.params.id,
      status: 'ready_for_signature'
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found or not ready for signature'));
    }

    if (!document.recipients || document.recipients.length === 0) {
      return next(new ApiError(400, 'Document has no recipients'));
    }
    
    // Validate recipient emails
    const invalidRecipients = document.recipients.filter(recipient => {
      const email = recipient.email;
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    });
    
    if (invalidRecipients.length > 0) {
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));
    }

    try {
      // Determine which file to use for Adobe Sign
      let fileToUpload = document.filePath;
      
      // If document was processed from DOCX/DOC, use the PDF version
      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {
        fileToUpload = document.pdfFilePath;
        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);
      }
      
      // Check if file exists
      if (!fs.existsSync(fileToUpload)) {
        logger.error(`File not found at path: ${fileToUpload}`);
        return next(new ApiError(404, 'Document file not found on server'));
      }
      
      // Get file stats to ensure it's not empty
      const fileStats = fs.statSync(fileToUpload);
      if (fileStats.size === 0) {
        logger.error(`File is empty: ${fileToUpload}`);
        return next(new ApiError(400, 'Document file is empty'));
      }
      
      // Upload as transient document
      logger.info(`Uploading document as transient document: ${document.originalName}`);
      const transientDocumentId = await uploadTransientDocument(fileToUpload);
      logger.info(`Document uploaded as transient document: ${transientDocumentId}`);
      
      // Ensure we have a webhook setup for status updates
      try {
        // Get access token
        const accessToken = await getAccessToken();
        
        // Setup webhook URL
        const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;
        
        // Check if webhook URL is HTTPS, which Adobe Sign requires
        const isHttps = webhookUrl.startsWith('https://');
        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');
        const isDevEnvironment = process.env.NODE_ENV === 'development';
        
        if (!isHttps && process.env.NODE_ENV === 'production') {
          logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);
        } 
        // Use mock implementation for development or non-HTTPS environments
        else if (webhookUrl) {
          try {
            // Import our improved webhook creator that handles non-HTTPS URLs
            const createWebhookLocal = require('../config/createWebhook');
            const webhookResult = await createWebhookLocal(accessToken, webhookUrl);
            
            if (webhookResult._mockImplementation) {
              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);
            } else {
              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`);
            }
          } catch (innerWebhookError) {
            // Log the error but continue with document sending
            logger.error(`Inner webhook error: ${innerWebhookError.message}`);
          }
        } else {
          logger.warn('No webhook URL configured for Adobe Sign updates');
        }
      } catch (webhookError) {
        // Log the error but continue with document sending
        logger.error(`Error setting up webhook: ${webhookError.message}`);
      }
      
      // Use the comprehensive approach from adobeSignFormFields utility
      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);
      const result = await createAgreementWithBestApproach(
        transientDocumentId,
        document.recipients,
        document.originalName,
        {
          templateId: document.templateId, // If using templates
          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],
          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)
        }
      );
      
      // Update document with Adobe Sign agreement ID
      document.adobeAgreementId = result.agreementId;
      document.status = 'sent_for_signature';
      document.adobeMetadata = {
        agreementId: result.agreementId,
        method: result.method,
        createdAt: new Date()
      };
      
      // Special handling for rate limiting
      if (result.rateLimited) {
        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);
        document.status = 'signature_error';
        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;
        document.adobeMetadata.rateLimited = true;
        document.adobeMetadata.retryAfter = result.retryAfter;
        document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));
        
        await document.save();
        
        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));
      }
      
      // Update recipients status
      document.recipients.forEach(recipient => {
        recipient.status = 'sent';
      });
      
      await document.save();
      
      // Step 4: Get and store signing URLs for all recipients
      try {
        const accessToken = await getAccessToken();
        const agreementInfo = await getAgreementInfo(accessToken, document.adobeAgreementId);
        
        if (agreementInfo.participantSets) {
          // Map recipients to participant sets and get their signing URLs
          for (const recipient of document.recipients) {
            for (const participantSet of agreementInfo.participantSets) {
              for (const participant of participantSet.memberInfos) {
                if (participant.email.toLowerCase() === recipient.email.toLowerCase()) {
                  try {
                    // Get signing URL for this participant
                    const signingUrlResponse = await getSigningUrl(
                      accessToken, 
                      document.adobeAgreementId,
                      participant.participantId
                    );
                    
                    if (signingUrlResponse.signingUrlSetInfos && 
                        signingUrlResponse.signingUrlSetInfos[0] && 
                        signingUrlResponse.signingUrlSetInfos[0].signingUrls && 
                        signingUrlResponse.signingUrlSetInfos[0].signingUrls[0]) {
                      
                      recipient.signingUrl = signingUrlResponse.signingUrlSetInfos[0].signingUrls[0].esignUrl;
                      logger.info(`Stored signing URL for ${recipient.email}`);
                    }
                  } catch (signingUrlError) {
                    logger.error(`Error getting signing URL for ${recipient.email}: ${signingUrlError.message}`);
                    // Continue with other recipients even if one fails
                  }
                  break;
                }
              }
            }
          }
          
          // Save the document with updated signing URLs
          await document.save();
        }
      } catch (signingUrlError) {
        logger.error(`Error retrieving signing URLs: ${signingUrlError.message}`);
        // Continue anyway - signing URLs can be retrieved later if needed
      }
      
      // Log document sent for signature
      await Log.create({
        level: 'info',
        message: `Document uploaded, prepared, and sent for signature using ${result.method} approach: ${document.originalName}`,
        documentId: document._id,
        ipAddress: req.ip,
        requestPath: req.originalUrl,
        requestMethod: req.method,
        metadata: {
          adobeAgreementId: result.agreementId,
          method: result.method,
          recipientCount: document.recipients.length,
          combined_operation: true
        }
      });
      
      logger.info(`Document uploaded, prepared, and sent for signature using ${result.method} approach: ${document.originalName}`);
      
      res.status(201).json(formatResponse(
        201,
        `Document uploaded, prepared, and sent for signature successfully using ${result.method} approach`,
        { 
          document,
          adobeAgreementId: result.agreementId,
          method: result.method,
          signingUrls: document.recipients.map(r => ({
            email: r.email,
            signingUrl: r.signingUrl
          })).filter(r => r.signingUrl)
        }
      ));
    } catch (adobeError) {
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);
      if (adobeError.response) {
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);
      }
      
      // Update document status to indicate error
      document.status = 'signature_error';
      document.errorMessage = adobeError.message;
      await document.save();
      
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`));
    }
  } catch (error) {
    next(error);
  }
};

/**
 * Get all documents for a user
 * @route GET /api/documents
 */
exports.getDocuments = async (req, res, next) => {
  try {
    const documents = await Document.find({})
      .sort({ createdAt: -1 });
    
    res.status(200).json(formatResponse(
      200,
      'Documents retrieved successfully',
      { documents }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Get a specific document
 * @route GET /api/documents/:id
 */
exports.getDocument = async (req, res, next) => {
  try {
    const document = await Document.findOne({ 
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }
    
    res.status(200).json(formatResponse(
      200,
      'Document retrieved successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Prepare document for e-signature
 * @route POST /api/documents/:id/prepare
 */
exports.prepareForSignature = async (req, res, next) => {
  try {
    let { recipients, signatureFieldMapping, signingFlow } = req.body;
    
    const document = await Document.findOne({
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }

    // If no recipients provided, try to extract from JSON template data
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {
      if (document.templateData) {
        logger.info('No recipients provided, extracting from template data');
        recipients = extractRecipientsFromTemplateData(document.templateData);
        
        if (!recipients || recipients.length === 0) {
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));
        }
        logger.info(`Extracted ${recipients.length} recipients from template data`);
        
        // Auto-generate signature field mapping from extracted recipients
        if (!signatureFieldMapping) {
          signatureFieldMapping = {};
          recipients.forEach(recipient => {
            if (recipient.signatureField) {
              signatureFieldMapping[recipient.email] = recipient.signatureField;
            }
          });
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);
        }
      } else {
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));
      }
    } else if (!Array.isArray(recipients)) {
      return next(new ApiError(400, 'Recipients must be an array'));
    }
    
    // Validate signing flow option
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) 
      ? signingFlow.toUpperCase() 
      : 'SEQUENTIAL'; // Default to sequential (updated default)
    
    // Validate and format recipients
    const formattedRecipients = recipients.map((recipient, index) => {
      if (!recipient.name || !recipient.email) {
        throw new ApiError(400, 'Each recipient must have a name and email');
      }
      
      return {
        name: recipient.name,
        email: recipient.email,
        order: index + 1,
        status: 'pending',
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`
      };
    });
    
    // Update document with recipients and signature field mapping
    document.recipients = formattedRecipients;
    document.status = 'ready_for_signature';
    document.signatureFieldMapping = signatureFieldMapping || {};
    document.signingFlow = selectedSigningFlow;
    await document.save();
    
    // Log document preparation
    await Log.create({
      level: 'info',
      message: `Document prepared for signature: ${document.originalName}`,
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,
      requestMethod: req.method,
      metadata: {
        recipientCount: recipients.length
      }
    });
    
    logger.info(`Document prepared for signature: ${document.originalName}`);
    
    res.status(200).json(formatResponse(
      200,
      'Document prepared for signature successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Send document for e-signature using the best approach
 * @route POST /api/documents/:id/send
 */
exports.sendForSignature = async (req, res, next) => {
  try {
    // First check if we're currently rate limited by Adobe Sign
    if (rateLimitProtection.isRateLimited()) {
      const timeRemaining = rateLimitProtection.getTimeRemaining();
      const status = rateLimitProtection.getRateLimitStatus();
      
      logger.warn(`Rate limit check failed: ${status}`);
      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));
    }
    
    // First validate Adobe Sign configuration
    const { validateAdobeSignConfig } = require('../config/adobeSign');
    const configValidation = validateAdobeSignConfig();
    
    if (!configValidation.isValid) {
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));
    }
    
    const document = await Document.findOne({
      _id: req.params.id,
      status: 'ready_for_signature'
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found or not ready for signature'));
    }

    if (!document.recipients || document.recipients.length === 0) {
      return next(new ApiError(400, 'Document has no recipients'));
    }
    
    // Validate recipient emails
    const invalidRecipients = document.recipients.filter(recipient => {
      const email = recipient.email;
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    });
    
    if (invalidRecipients.length > 0) {
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));
    }

    try {
      // Determine which file to use for Adobe Sign
      let fileToUpload = document.filePath;
      
      // If document was processed from DOCX/DOC, use the PDF version
      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {
        fileToUpload = document.pdfFilePath;
        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);
      }
      
      // Check if file exists
      if (!fs.existsSync(fileToUpload)) {
        logger.error(`File not found at path: ${fileToUpload}`);
        return next(new ApiError(404, 'Document file not found on server'));
      }
      
      // Get file stats to ensure it's not empty
      const fileStats = fs.statSync(fileToUpload);
      if (fileStats.size === 0) {
        logger.error(`File is empty: ${fileToUpload}`);
        return next(new ApiError(400, 'Document file is empty'));
      }
      
      // Upload as transient document
      logger.info(`Uploading document as transient document: ${document.originalName}`);
      const transientDocumentId = await uploadTransientDocument(fileToUpload);
      logger.info(`Document uploaded as transient document: ${transientDocumentId}`);
      
      // Ensure we have a webhook setup for status updates
      try {
        // Get access token
        const accessToken = await getAccessToken();
        
        // Setup webhook URL
        const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;
        
        // Check if webhook URL is HTTPS, which Adobe Sign requires
        const isHttps = webhookUrl.startsWith('https://');
        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');
        const isDevEnvironment = process.env.NODE_ENV === 'development';
        
        if (!isHttps && process.env.NODE_ENV === 'production') {
          logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);
        } 
        // Use mock implementation for development or non-HTTPS environments
        else if (webhookUrl) {
          try {
            // Import our improved webhook creator that handles non-HTTPS URLs
            const createWebhookLocal = require('../config/createWebhook');
            const webhookResult = await createWebhookLocal(accessToken, webhookUrl);
            
            if (webhookResult._mockImplementation) {
              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);
            } else {
              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`);
            }
          } catch (innerWebhookError) {
            // Log the error but continue with document sending
            logger.error(`Inner webhook error: ${innerWebhookError.message}`);
          }
        } else {
          logger.warn('No webhook URL configured for Adobe Sign updates');
        }
      } catch (webhookError) {
        // Log the error but continue with document sending
        logger.error(`Error setting up webhook: ${webhookError.message}`);
      }
      
      // Use the comprehensive approach from adobeSignFormFields utility
      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);
      const result = await createAgreementWithBestApproach(
        transientDocumentId,
        document.recipients,
        document.originalName,
        {
          templateId: document.templateId, // If using templates
          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],
          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)
        }
      );
      
      // Update document with Adobe Sign agreement ID
      document.adobeAgreementId = result.agreementId;
      document.status = 'sent_for_signature';
      document.adobeMetadata = {
        agreementId: result.agreementId,
        method: result.method,
        createdAt: new Date()
      };
      
      // Special handling for rate limiting
      if (result.rateLimited) {
        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);
        document.status = 'signature_error';
        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;
        document.adobeMetadata.rateLimited = true;
        document.adobeMetadata.retryAfter = result.retryAfter;
        document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));
        
        await document.save();
        
        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));
      }
      
      // Update recipients status
      document.recipients.forEach(recipient => {
        recipient.status = 'sent';
      });
      
      await document.save();
      
      // Step 4: Get and store signing URLs for all recipients
      try {
        const accessToken = await getAccessToken();
        const agreementInfo = await getAgreementInfo(accessToken, document.adobeAgreementId);
        
        if (agreementInfo.participantSets) {
          // Map recipients to participant sets and get their signing URLs
          for (const recipient of document.recipients) {
            for (const participantSet of agreementInfo.participantSets) {
              for (const participant of participantSet.memberInfos) {
                if (participant.email.toLowerCase() === recipient.email.toLowerCase()) {
                  try {
                    // Get signing URL for this participant
                    const signingUrlResponse = await getSigningUrl(
                      accessToken, 
                      document.adobeAgreementId,
                      participant.participantId
                    );
                    
                    if (signingUrlResponse.signingUrlSetInfos && 
                        signingUrlResponse.signingUrlSetInfos[0] && 
                        signingUrlResponse.signingUrlSetInfos[0].signingUrls && 
                        signingUrlResponse.signingUrlSetInfos[0].signingUrls[0]) {
                      
                      recipient.signingUrl = signingUrlResponse.signingUrlSetInfos[0].signingUrls[0].esignUrl;
                      logger.info(`Stored signing URL for ${recipient.email}`);
                    }
                  } catch (signingUrlError) {
                    logger.error(`Error getting signing URL for ${recipient.email}: ${signingUrlError.message}`);
                    // Continue with other recipients even if one fails
                  }
                  break;
                }
              }
            }
          }
          
          // Save the document with updated signing URLs
          await document.save();
        }
      } catch (signingUrlError) {
        logger.error(`Error retrieving signing URLs: ${signingUrlError.message}`);
        // Continue anyway - signing URLs can be retrieved later if needed
      }
      
      // Log document sent for signature
      await Log.create({
        level: 'info',
        message: `Document uploaded, prepared, and sent for signature using ${result.method} approach: ${document.originalName}`,
        documentId: document._id,
        ipAddress: req.ip,
        requestPath: req.originalUrl,
        requestMethod: req.method,
        metadata: {
          adobeAgreementId: result.agreementId,
          method: result.method,
          recipientCount: document.recipients.length,
          combined_operation: true
        }
      });
      
      logger.info(`Document uploaded, prepared, and sent for signature using ${result.method} approach: ${document.originalName}`);
      
      res.status(201).json(formatResponse(
        201,
        `Document uploaded, prepared, and sent for signature successfully using ${result.method} approach`,
        { 
          document,
          adobeAgreementId: result.agreementId,
          method: result.method,
          signingUrls: document.recipients.map(r => ({
            email: r.email,
            signingUrl: r.signingUrl
          })).filter(r => r.signingUrl)
        }
      ));
    } catch (adobeError) {
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);
      if (adobeError.response) {
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);
      }
      
      // Update document status to indicate error
      document.status = 'signature_error';
      document.errorMessage = adobeError.message;
      await document.save();
      
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`));
    }
  } catch (error) {
    next(error);
  }
};

/**
 * Get all documents for a user
 * @route GET /api/documents
 */
exports.getDocuments = async (req, res, next) => {
  try {
    const documents = await Document.find({})
      .sort({ createdAt: -1 });
    
    res.status(200).json(formatResponse(
      200,
      'Documents retrieved successfully',
      { documents }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Get a specific document
 * @route GET /api/documents/:id
 */
exports.getDocument = async (req, res, next) => {
  try {
    const document = await Document.findOne({ 
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }
    
    res.status(200).json(formatResponse(
      200,
      'Document retrieved successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Prepare document for e-signature
 * @route POST /api/documents/:id/prepare
 */
exports.prepareForSignature = async (req, res, next) => {
  try {
    let { recipients, signatureFieldMapping, signingFlow } = req.body;
    
    const document = await Document.findOne({
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }

    // If no recipients provided, try to extract from JSON template data
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {
      if (document.templateData) {
        logger.info('No recipients provided, extracting from template data');
        recipients = extractRecipientsFromTemplateData(document.templateData);
        
        if (!recipients || recipients.length === 0) {
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));
        }
        logger.info(`Extracted ${recipients.length} recipients from template data`);
        
        // Auto-generate signature field mapping from extracted recipients
        if (!signatureFieldMapping) {
          signatureFieldMapping = {};
          recipients.forEach(recipient => {
            if (recipient.signatureField) {
              signatureFieldMapping[recipient.email] = recipient.signatureField;
            }
          });
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);
        }
      } else {
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));
      }
    } else if (!Array.isArray(recipients)) {
      return next(new ApiError(400, 'Recipients must be an array'));
    }
    
    // Validate signing flow option
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) 
      ? signingFlow.toUpperCase() 
      : 'SEQUENTIAL'; // Default to sequential (updated default)
    
    // Validate and format recipients
    const formattedRecipients = recipients.map((recipient, index) => {
      if (!recipient.name || !recipient.email) {
        throw new ApiError(400, 'Each recipient must have a name and email');
      }
      
      return {
        name: recipient.name,
        email: recipient.email,
        order: index + 1,
        status: 'pending',
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`
      };
    });
    
    // Update document with recipients and signature field mapping
    document.recipients = formattedRecipients;
    document.status = 'ready_for_signature';
    document.signatureFieldMapping = signatureFieldMapping || {};
    document.signingFlow = selectedSigningFlow;
    await document.save();
    
    // Log document preparation
    await Log.create({
      level: 'info',
      message: `Document prepared for signature: ${document.originalName}`,
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,
      requestMethod: req.method,
      metadata: {
        recipientCount: recipients.length
      }
    });
    
    logger.info(`Document prepared for signature: ${document.originalName}`);
    
    res.status(200).json(formatResponse(
      200,
      'Document prepared for signature successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Send document for e-signature using the best approach
 * @route POST /api/documents/:id/send
 */
exports.sendForSignature = async (req, res, next) => {
  try {
    // First check if we're currently rate limited by Adobe Sign
    if (rateLimitProtection.isRateLimited()) {
      const timeRemaining = rateLimitProtection.getTimeRemaining();
      const status = rateLimitProtection.getRateLimitStatus();
      
      logger.warn(`Rate limit check failed: ${status}`);
      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));
    }
    
    // First validate Adobe Sign configuration
    const { validateAdobeSignConfig } = require('../config/adobeSign');
    const configValidation = validateAdobeSignConfig();
    
    if (!configValidation.isValid) {
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));
    }
    
    const document = await Document.findOne({
      _id: req.params.id,
      status: 'ready_for_signature'
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found or not ready for signature'));
    }

    if (!document.recipients || document.recipients.length === 0) {
      return next(new ApiError(400, 'Document has no recipients'));
    }
    
    // Validate recipient emails
    const invalidRecipients = document.recipients.filter(recipient => {
      const email = recipient.email;
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    });
    
    if (invalidRecipients.length > 0) {
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));
    }

    try {
      // Determine which file to use for Adobe Sign
      let fileToUpload = document.filePath;
      
      // If document was processed from DOCX/DOC, use the PDF version
      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {
        fileToUpload = document.pdfFilePath;
        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);
      }
      
      // Check if file exists
      if (!fs.existsSync(fileToUpload)) {
        logger.error(`File not found at path: ${fileToUpload}`);
        return next(new ApiError(404, 'Document file not found on server'));
      }
      
      // Get file stats to ensure it's not empty
      const fileStats = fs.statSync(fileToUpload);
      if (fileStats.size === 0) {
        logger.error(`File is empty: ${fileToUpload}`);
        return next(new ApiError(400, 'Document file is empty'));
      }
      
      // Upload as transient document
      logger.info(`Uploading document as transient document: ${document.originalName}`);
      const transientDocumentId = await uploadTransientDocument(fileToUpload);
      logger.info(`Document uploaded as transient document: ${transientDocumentId}`);
      
      // Ensure we have a webhook setup for status updates
      try {
        // Get access token
        const accessToken = await getAccessToken();
        
        // Setup webhook URL
        const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;
        
        // Check if webhook URL is HTTPS, which Adobe Sign requires
        const isHttps = webhookUrl.startsWith('https://');
        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');
        const isDevEnvironment = process.env.NODE_ENV === 'development';
        
        if (!isHttps && process.env.NODE_ENV === 'production') {
          logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);
        } 
        // Use mock implementation for development or non-HTTPS environments
        else if (webhookUrl) {
          try {
            // Import our improved webhook creator that handles non-HTTPS URLs
            const createWebhookLocal = require('../config/createWebhook');
            const webhookResult = await createWebhookLocal(accessToken, webhookUrl);
            
            if (webhookResult._mockImplementation) {
              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);
            } else {
              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`);
            }
          } catch (innerWebhookError) {
            // Log the error but continue with document sending
            logger.error(`Inner webhook error: ${innerWebhookError.message}`);
          }
        } else {
          logger.warn('No webhook URL configured for Adobe Sign updates');
        }
      } catch (webhookError) {
        // Log the error but continue with document sending
        logger.error(`Error setting up webhook: ${webhookError.message}`);
      }
      
      // Use the comprehensive approach from adobeSignFormFields utility
      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);
      const result = await createAgreementWithBestApproach(
        transientDocumentId,
        document.recipients,
        document.originalName,
        {
          templateId: document.templateId, // If using templates
          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],
          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)
        }
      );
      
      // Update document with Adobe Sign agreement ID
      document.adobeAgreementId = result.agreementId;
      document.status = 'sent_for_signature';
      document.adobeMetadata = {
        agreementId: result.agreementId,
        method: result.method,
        createdAt: new Date()
      };
      
      // Special handling for rate limiting
      if (result.rateLimited) {
        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);
        document.status = 'signature_error';
        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;
        document.adobeMetadata.rateLimited = true;
        document.adobeMetadata.retryAfter = result.retryAfter;
        document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));
        
        await document.save();
        
        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));
      }
      
      // Update recipients status
      document.recipients.forEach(recipient => {
        recipient.status = 'sent';
      });
      
      await document.save();
      
      // Step 4: Get and store signing URLs for all recipients
      try {
        const accessToken = await getAccessToken();
        const agreementInfo = await getAgreementInfo(accessToken, document.adobeAgreementId);
        
        if (agreementInfo.participantSets) {
          // Map recipients to participant sets and get their signing URLs
          for (const recipient of document.recipients) {
            for (const participantSet of agreementInfo.participantSets) {
              for (const participant of participantSet.memberInfos) {
                if (participant.email.toLowerCase() === recipient.email.toLowerCase()) {
                  try {
                    // Get signing URL for this participant
                    const signingUrlResponse = await getSigningUrl(
                      accessToken, 
                      document.adobeAgreementId,
                      participant.participantId
                    );
                    
                    if (signingUrlResponse.signingUrlSetInfos && 
                        signingUrlResponse.signingUrlSetInfos[0] && 
                        signingUrlResponse.signingUrlSetInfos[0].signingUrls && 
                        signingUrlResponse.signingUrlSetInfos[0].signingUrls[0]) {
                      
                      recipient.signingUrl = signingUrlResponse.signingUrlSetInfos[0].signingUrls[0].esignUrl;
                      logger.info(`Stored signing URL for ${recipient.email}`);
                    }
                  } catch (signingUrlError) {
                    logger.error(`Error getting signing URL for ${recipient.email}: ${signingUrlError.message}`);
                    // Continue with other recipients even if one fails
                  }
                  break;
                }
              }
            }
          }
          
          // Save the document with updated signing URLs
          await document.save();
        }
      } catch (signingUrlError) {
        logger.error(`Error retrieving signing URLs: ${signingUrlError.message}`);
        // Continue anyway - signing URLs can be retrieved later if needed
      }
      
      // Log document sent for signature
      await Log.create({
        level: 'info',
        message: `Document uploaded, prepared, and sent for signature using ${result.method} approach: ${document.originalName}`,
        documentId: document._id,
        ipAddress: req.ip,
        requestPath: req.originalUrl,
        requestMethod: req.method,
        metadata: {
          adobeAgreementId: result.agreementId,
          method: result.method,
          recipientCount: document.recipients.length,
          combined_operation: true
        }
      });
      
      logger.info(`Document uploaded, prepared, and sent for signature using ${result.method} approach: ${document.originalName}`);
      
      res.status(201).json(formatResponse(
        201,
        `Document uploaded, prepared, and sent for signature successfully using ${result.method} approach`,
        { 
          document,
          adobeAgreementId: result.agreementId,
          method: result.method,
          signingUrls: document.recipients.map(r => ({
            email: r.email,
            signingUrl: r.signingUrl
          })).filter(r => r.signingUrl)
        }
      ));
    } catch (adobeError) {
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);
      if (adobeError.response) {
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);
      }
      
      // Update document status to indicate error
      document.status = 'signature_error';
      document.errorMessage = adobeError.message;
      await document.save();
      
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`));
    }
  } catch (error) {
    next(error);
  }
};

/**
 * Get all documents for a user
 * @route GET /api/documents
 */
exports.getDocuments = async (req, res, next) => {
  try {
    const documents = await Document.find({})
      .sort({ createdAt: -1 });
    
    res.status(200).json(formatResponse(
      200,
      'Documents retrieved successfully',
      { documents }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Get a specific document
 * @route GET /api/documents/:id
 */
exports.getDocument = async (req, res, next) => {
  try {
    const document = await Document.findOne({ 
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }
    
    res.status(200).json(formatResponse(
      200,
      'Document retrieved successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Prepare document for e-signature
 * @route POST /api/documents/:id/prepare
 */
exports.prepareForSignature = async (req, res, next) => {
  try {
    let { recipients, signatureFieldMapping, signingFlow } = req.body;
    
    const document = await Document.findOne({
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }

    // If no recipients provided, try to extract from JSON template data
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {
      if (document.templateData) {
        logger.info('No recipients provided, extracting from template data');
        recipients = extractRecipientsFromTemplateData(document.templateData);
        
        if (!recipients || recipients.length === 0) {
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));
        }
        logger.info(`Extracted ${recipients.length} recipients from template data`);
        
        // Auto-generate signature field mapping from extracted recipients
        if (!signatureFieldMapping) {
          signatureFieldMapping = {};
          recipients.forEach(recipient => {
            if (recipient.signatureField) {
              signatureFieldMapping[recipient.email] = recipient.signatureField;
            }
          });
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);
        }
      } else {
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));
      }
    } else if (!Array.isArray(recipients)) {
      return next(new ApiError(400, 'Recipients must be an array'));
    }
    
    // Validate signing flow option
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) 
      ? signingFlow.toUpperCase() 
      : 'SEQUENTIAL'; // Default to sequential (updated default)
    
    // Validate and format recipients
    const formattedRecipients = recipients.map((recipient, index) => {
      if (!recipient.name || !recipient.email) {
        throw new ApiError(400, 'Each recipient must have a name and email');
      }
      
      return {
        name: recipient.name,
        email: recipient.email,
        order: index + 1,
        status: 'pending',
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`
      };
    });
    
    // Update document with recipients and signature field mapping
    document.recipients = formattedRecipients;
    document.status = 'ready_for_signature';
    document.signatureFieldMapping = signatureFieldMapping || {};
    document.signingFlow = selectedSigningFlow;
    await document.save();
    
    // Log document preparation
    await Log.create({
      level: 'info',
      message: `Document prepared for signature: ${document.originalName}`,
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,
      requestMethod: req.method,
      metadata: {
        recipientCount: recipients.length
      }
    });
    
    logger.info(`Document prepared for signature: ${document.originalName}`);
    
    res.status(200).json(formatResponse(
      200,
      'Document prepared for signature successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Send document for e-signature using the best approach
 * @route POST /api/documents/:id/send
 */
exports.sendForSignature = async (req, res, next) => {
  try {
    // First check if we're currently rate limited by Adobe Sign
    if (rateLimitProtection.isRateLimited()) {
      const timeRemaining = rateLimitProtection.getTimeRemaining();
      const status = rateLimitProtection.getRateLimitStatus();
      
      logger.warn(`Rate limit check failed: ${status}`);
      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));
    }
    
    // First validate Adobe Sign configuration
    const { validateAdobeSignConfig } = require('../config/adobeSign');
    const configValidation = validateAdobeSignConfig();
    
    if (!configValidation.isValid) {
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));
    }
    
    const document = await Document.findOne({
      _id: req.params.id,
      status: 'ready_for_signature'
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found or not ready for signature'));
    }

    if (!document.recipients || document.recipients.length === 0) {
      return next(new ApiError(400, 'Document has no recipients'));
    }
    
    // Validate recipient emails
    const invalidRecipients = document.recipients.filter(recipient => {
      const email = recipient.email;
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    });
    
    if (invalidRecipients.length > 0) {
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients.map(r => r.email || 'missing email').join(', ')}`));
    }

    try {
      // Determine which file to use for Adobe Sign
      let fileToUpload = document.filePath;
      
      // If document was processed from DOCX/DOC, use the PDF version
      if (document.pdfFilePath && fs.existsSync(document.pdfFilePath)) {
        fileToUpload = document.pdfFilePath;
        logger.info(`Using converted PDF file: ${document.pdfFilePath}`);
      }
      
      // Check if file exists
      if (!fs.existsSync(fileToUpload)) {
        logger.error(`File not found at path: ${fileToUpload}`);
        return next(new ApiError(404, 'Document file not found on server'));
      }
      
      // Get file stats to ensure it's not empty
      const fileStats = fs.statSync(fileToUpload);
      if (fileStats.size === 0) {
        logger.error(`File is empty: ${fileToUpload}`);
        return next(new ApiError(400, 'Document file is empty'));
      }
      
      // Upload as transient document
      logger.info(`Uploading document as transient document: ${document.originalName}`);
      const transientDocumentId = await uploadTransientDocument(fileToUpload);
      logger.info(`Document uploaded as transient document: ${transientDocumentId}`);
      
      // Ensure we have a webhook setup for status updates
      try {
        // Get access token
        const accessToken = await getAccessToken();
        
        // Setup webhook URL
        const webhookUrl = process.env.ADOBE_WEBHOOK_URL || `${req.protocol}://${req.get('host')}/api/webhooks/adobe-sign`;
        
        // Check if webhook URL is HTTPS, which Adobe Sign requires
        const isHttps = webhookUrl.startsWith('https://');
        const isLocalhost = webhookUrl.includes('localhost') || webhookUrl.includes('127.0.0.1');
        const isDevEnvironment = process.env.NODE_ENV === 'development';
        
        if (!isHttps && process.env.NODE_ENV === 'production') {
          logger.warn(`Skipping webhook setup as Adobe Sign requires HTTPS URLs in production: ${webhookUrl}`);
        } 
        // Use mock implementation for development or non-HTTPS environments
        else if (webhookUrl) {
          try {
            // Import our improved webhook creator that handles non-HTTPS URLs
            const createWebhookLocal = require('../config/createWebhook');
            const webhookResult = await createWebhookLocal(accessToken, webhookUrl);
            
            if (webhookResult._mockImplementation) {
              logger.info(`Mock webhook setup for Adobe Sign: ${webhookUrl} (reason: ${webhookResult._mockReason || 'mock'})`);
            } else {
              logger.info(`Real webhook setup for Adobe Sign: ${webhookUrl}`);
            }
          } catch (innerWebhookError) {
            // Log the error but continue with document sending
            logger.error(`Inner webhook error: ${innerWebhookError.message}`);
          }
        } else {
          logger.warn('No webhook URL configured for Adobe Sign updates');
        }
      } catch (webhookError) {
        // Log the error but continue with document sending
        logger.error(`Error setting up webhook: ${webhookError.message}`);
      }
      
      // Use the comprehensive approach from adobeSignFormFields utility
      logger.info(`Using comprehensive approach to create agreement: ${document.originalName}`);
      const result = await createAgreementWithBestApproach(
        transientDocumentId,
        document.recipients,
        document.originalName,
        {
          templateId: document.templateId, // If using templates
          autoDetectedSignatureFields: document.autoDetectedSignatureFields || [],
          signingFlow: document.signingFlow || 'SEQUENTIAL' // Pass the signing flow option (default to sequential)
        }
      );
      
      // Update document with Adobe Sign agreement ID
      document.adobeAgreementId = result.agreementId;
      document.status = 'sent_for_signature';
      document.adobeMetadata = {
        agreementId: result.agreementId,
        method: result.method,
        createdAt: new Date()
      };
      
      // Special handling for rate limiting
      if (result.rateLimited) {
        logger.warn(`Adobe Sign rate limit reached. Retry after ${result.retryAfter} seconds.`);
        document.status = 'signature_error';
        document.errorMessage = `Rate limit reached. Please try again later (after ${Math.ceil(result.retryAfter / 60)} minutes).`;
        document.adobeMetadata.rateLimited = true;
        document.adobeMetadata.retryAfter = result.retryAfter;
        document.adobeMetadata.retryAfterDate = new Date(Date.now() + (result.retryAfter * 1000));
        
        await document.save();
        
        return next(new ApiError(429, `Adobe Sign rate limit reached. Please try again after ${Math.ceil(result.retryAfter / 60)} minutes.`));
      }
      
      // Update recipients status
      document.recipients.forEach(recipient => {
        recipient.status = 'sent';
      });
      
      await document.save();
      
      // Step 4: Get and store signing URLs for all recipients
      try {
        const accessToken = await getAccessToken();
        const agreementInfo = await getAgreementInfo(accessToken, document.adobeAgreementId);
        
        if (agreementInfo.participantSets) {
          // Map recipients to participant sets and get their signing URLs
          for (const recipient of document.recipients) {
            for (const participantSet of agreementInfo.participantSets) {
              for (const participant of participantSet.memberInfos) {
                if (participant.email.toLowerCase() === recipient.email.toLowerCase()) {
                  try {
                    // Get signing URL for this participant
                    const signingUrlResponse = await getSigningUrl(
                      accessToken, 
                      document.adobeAgreementId,
                      participant.participantId
                    );
                    
                    if (signingUrlResponse.signingUrlSetInfos && 
                        signingUrlResponse.signingUrlSetInfos[0] && 
                        signingUrlResponse.signingUrlSetInfos[0].signingUrls && 
                        signingUrlResponse.signingUrlSetInfos[0].signingUrls[0]) {
                      
                      recipient.signingUrl = signingUrlResponse.signingUrlSetInfos[0].signingUrls[0].esignUrl;
                      logger.info(`Stored signing URL for ${recipient.email}`);
                    }
                  } catch (signingUrlError) {
                    logger.error(`Error getting signing URL for ${recipient.email}: ${signingUrlError.message}`);
                    // Continue with other recipients even if one fails
                  }
                  break;
                }
              }
            }
          }
          
          // Save the document with updated signing URLs
          await document.save();
        }
      } catch (signingUrlError) {
        logger.error(`Error retrieving signing URLs: ${signingUrlError.message}`);
        // Continue anyway - signing URLs can be retrieved later if needed
      }
      
      // Log document sent for signature
      await Log.create({
        level: 'info',
        message: `Document uploaded, prepared, and sent for signature using ${result.method} approach: ${document.originalName}`,
        documentId: document._id,
        ipAddress: req.ip,
        requestPath: req.originalUrl,
        requestMethod: req.method,
        metadata: {
          adobeAgreementId: result.agreementId,
          method: result.method,
          recipientCount: document.recipients.length,
          combined_operation: true
        }
      });
      
      logger.info(`Document uploaded, prepared, and sent for signature using ${result.method} approach: ${document.originalName}`);
      
      res.status(201).json(formatResponse(
        201,
        `Document uploaded, prepared, and sent for signature successfully using ${result.method} approach`,
        { 
          document,
          adobeAgreementId: result.agreementId,
          method: result.method,
          signingUrls: document.recipients.map(r => ({
            email: r.email,
            signingUrl: r.signingUrl
          })).filter(r => r.signingUrl)
        }
      ));
    } catch (adobeError) {
      logger.error(`Adobe Sign API Error: ${adobeError.message}`);
      if (adobeError.response) {
        logger.error(`Status: ${adobeError.response.status}, Data: ${JSON.stringify(adobeError.response.data)}`);
      }
      
      // Update document status to indicate error
      document.status = 'signature_error';
      document.errorMessage = adobeError.message;
      await document.save();
      
      return next(new ApiError(500, `Failed to send document for signature: ${adobeError.message}`));
    }
  } catch (error) {
    next(error);
  }
};

/**
 * Get all documents for a user
 * @route GET /api/documents
 */
exports.getDocuments = async (req, res, next) => {
  try {
    const documents = await Document.find({})
      .sort({ createdAt: -1 });
    
    res.status(200).json(formatResponse(
      200,
      'Documents retrieved successfully',
      { documents }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Get a specific document
 * @route GET /api/documents/:id
 */
exports.getDocument = async (req, res, next) => {
  try {
    const document = await Document.findOne({ 
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }
    
    res.status(200).json(formatResponse(
      200,
      'Document retrieved successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Prepare document for e-signature
 * @route POST /api/documents/:id/prepare
 */
exports.prepareForSignature = async (req, res, next) => {
  try {
    let { recipients, signatureFieldMapping, signingFlow } = req.body;
    
    const document = await Document.findOne({
      _id: req.params.id
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found'));
    }

    // If no recipients provided, try to extract from JSON template data
    if (!recipients || (Array.isArray(recipients) && recipients.length === 0)) {
      if (document.templateData) {
        logger.info('No recipients provided, extracting from template data');
        recipients = extractRecipientsFromTemplateData(document.templateData);
        
        if (!recipients || recipients.length === 0) {
          return next(new ApiError(400, 'Recipients are required either in request body or template data. No recipients found in template data.'));
        }
        logger.info(`Extracted ${recipients.length} recipients from template data`);
        
        // Auto-generate signature field mapping from extracted recipients
        if (!signatureFieldMapping) {
          signatureFieldMapping = {};
          recipients.forEach(recipient => {
            if (recipient.signatureField) {
              signatureFieldMapping[recipient.email] = recipient.signatureField;
            }
          });
          logger.info(`Auto-generated signature field mapping for ${Object.keys(signatureFieldMapping).length} recipients`);
        }
      } else {
        return next(new ApiError(400, 'Recipients are required either in request body or template data'));
      }
    } else if (!Array.isArray(recipients)) {
      return next(new ApiError(400, 'Recipients must be an array'));
    }
    
    // Validate signing flow option
    const validSigningFlows = ['SEQUENTIAL', 'PARALLEL'];
    const selectedSigningFlow = signingFlow && validSigningFlows.includes(signingFlow.toUpperCase()) 
      ? signingFlow.toUpperCase() 
      : 'SEQUENTIAL'; // Default to sequential (updated default)
    
    // Validate and format recipients
    const formattedRecipients = recipients.map((recipient, index) => {
      if (!recipient.name || !recipient.email) {
        throw new ApiError(400, 'Each recipient must have a name and email');
      }
      
      return {
        name: recipient.name,
        email: recipient.email,
        order: index + 1,
        status: 'pending',
        signatureField: recipient.signatureField || signatureFieldMapping?.[recipient.email] || `signature_${index + 1}`
      };
    });
    
    // Update document with recipients and signature field mapping
    document.recipients = formattedRecipients;
    document.status = 'ready_for_signature';
    document.signatureFieldMapping = signatureFieldMapping || {};
    document.signingFlow = selectedSigningFlow;
    await document.save();
    
    // Log document preparation
    await Log.create({
      level: 'info',
      message: `Document prepared for signature: ${document.originalName}`,
      documentId: document._id,
      ipAddress: req.ip,
      requestPath: req.originalUrl,
      requestMethod: req.method,
      metadata: {
        recipientCount: recipients.length
      }
    });
    
    logger.info(`Document prepared for signature: ${document.originalName}`);
    
    res.status(200).json(formatResponse(
      200,
      'Document prepared for signature successfully',
      { document }
    ));
  } catch (error) {
    next(error);
  }
};

/**
 * Send document for e-signature using the best approach
 * @route POST /api/documents/:id/send
 */
exports.sendForSignature = async (req, res, next) => {
  try {
    // First check if we're currently rate limited by Adobe Sign
    if (rateLimitProtection.isRateLimited()) {
      const timeRemaining = rateLimitProtection.getTimeRemaining();
      const status = rateLimitProtection.getRateLimitStatus();
      
      logger.warn(`Rate limit check failed: ${status}`);
      return next(new ApiError(429, `Adobe Sign rate limit in effect. Please try again after ${Math.ceil(timeRemaining / 60)} minutes.`));
    }
    
    // First validate Adobe Sign configuration
    const { validateAdobeSignConfig } = require('../config/adobeSign');
    const configValidation = validateAdobeSignConfig();
    
    if (!configValidation.isValid) {
      logger.error('Adobe Sign configuration validation failed:', configValidation.errors);
      return next(new ApiError(500, `Adobe Sign configuration error: ${configValidation.errors.join(', ')}`));
    }
    
    const document = await Document.findOne({
      _id: req.params.id,
      status: 'ready_for_signature'
    });
    
    if (!document) {
      return next(new ApiError(404, 'Document not found or not ready for signature'));
    }

    if (!document.recipients || document.recipients.length === 0) {
      return next(new ApiError(400, 'Document has no recipients'));
    }
    
    // Validate recipient emails
    const invalidRecipients = document.recipients.filter(recipient => {
      const email = recipient.email;
      return !email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    });
    
    if (invalidRecipients.length > 0) {
      return next(new ApiError(400, `Invalid recipient email addresses: ${invalidRecipients